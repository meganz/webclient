/**
    @module rtcSession
*/
"use strict"

/**

    @class
        An RtcSession instance handles all jingle and webRTC operations
        for the Strophe connection object on which it was created, i.e. it
        adds webRTC support for that connection.
        To perform media calls, call its methods.
        To handle events generated by it, attach handlers to it.
        All events are called on the RtcSession
        instance and, since this object is not a DOM object, no bubbling will occur.
        Therefore, you should attach all event handlers to the RTC session instance.
        The handlers are called with the RtcSession instance as the <i>this</i> object.
    @param {Strophe.connection} stropheConn
        The Strophe connection object to add Jingle/webRTC support to
    @param {object} options
        Configuration options
    @param {object[]} [options.iceServers] Initially sets the ice servers that will be used
        in a call. These can be updated at any time via updateIceServers()
        iceServers is an array of objects, each describing a TURN or STUN server, like so:
        [{url: 'stun:stun.l.google.com:19302'}].
        There are also other properties, such as credentials - for more info about the structure,
        see the standard webrtc API documentation.
        If no ICE servers are specified at construction, they must be specified prior to
        starting a call. Otherwise NAT won't be traversed.
    @param {boolean} [dummyCryptoFunctions] If this flag is provided and is true,
        then all crypto functions will be set to default dummy implementations, and the
        crypto object (see below) is not required and will be ignored.
        This is used only for debugging and testing purposes.
    @param {object} [crypto] An object holding all crypto functions that need to be provided
    to the RtcSession object.
    @param {function} options.crypto.encryptMessageForJid
        A function to encrypt the local SRTP fingerprint(or any other message)
        with the specified bare JID's public key. The function's signature is
        <i> encryptMessageForJid(msg:string, bareJid: string): string </i>
        It returns the encrypted message encoded in a string. If there is an error, the
        function must throw an exception
    @param {function} options.crypto.decryptMessage
        A function that does the reverse of encryptMessageForJid() - given the
        message, encrypted by that function, encrypted for us (with our public key),
        decrypts it with our private key and returns it.
        The function signature is <i>decryptMessage(msg:string): string</i>
        If there was an error, the function must throw an exception
    @param {function} options.crypto.generateMac
        A function that takes a message and a key and returns a MAC. Can be any
        standard MAC function such as hmac-sha1 or similar
        Signature: <i> generateMac(msg:string, key:string):string
        If there is an error, the function must throw an exception
    @param {function} [options.crypto.generateMacKey]
        A function that generates a new, unpredictably random, never-used-before
        mac key, used to verify certificate fingerprints.
        If it is not provided, a built-in implementation is used that utilizes
        crypto.getRandomValues() to generate a 256-bit (32-byte, 8-int) key,
        encoding in base64 format.
        The function takes no parameters and returns the generated string.
    @param {function} [options.crypto.preloadCryptoKeyForJid]
        A function that preloads the public key of the peer jid and then calls the
        callback given. Used to send the first message when initiating
        a session. It takes two parameters (sendmsg, jid), where sendmsg is a
        0-argument function "sendmsg", and jid is the targetJid.
        If this is not provided, function(sendmsg, jid) { sendmsg(); } is used,
        which executes it immediately.
    @param {function} [options.crypto.scrambleJid]
        This function scrambles a given JID using our private key.
        This is necessary for anonymizing jids in call ids for
        webrtc statistics. It takes one string parameter, and returns a string.
        This function is synchronous.
    @returns {RtcSession}
*/

function RtcSession(stropheConn, options) {
    if (!RTC)
        throw new RtcSession.NotSupportedError('This browser does not support webRTC');

    var self = this;

    self.connection = stropheConn;
    self.gLocalStream = null;
    self.gLocalVid = null;

    var j = self.jingle = stropheConn.jingle;
    if (j.rtcSession)
        throw new Error("This Strophe connection already has an associated RtcSession instance");
    self.ftManager = j.ftManager;
// Init crypto functions
    if (options.dummyCryptoFunctions) {
        j.encryptMessageForJid = function(msg, bareJid) {
            if (!self._dummyKeys || !self._dummyKeys[bareJid]) {
                throw new Error("pubkey not loaded: " + bareJid);
            }
            return RtcSession.xorEnc(msg, bareJid)
        };
        j.decryptMessage = function(msg) {
            return RtcSession.xorDec(msg, Strophe.getBareJidFromJid(self.connection.jid));
        };
        j.generateMac = function(msg, key) {
            return RtcSession.xorEnc(msg, key);
        };
        j.preloadCryptoKeyForJid = function(f, bareJid) {
            self._dummyKeys = self._dummyKeys || {};
            self._dummyKeys[bareJid] = true;
            f();
        };
        self.scrambleJid = function(jid) {
            //dummy scrambling uses our bare jid as a key
            return "_fake"+MD5.hexdigest(Strophe.getBareJidFromJid(jid));
        }
    } else {
        var cr = options.crypto;
        if (!cr.encryptMessageForJid || !cr.decryptMessage || !cr.generateMac ||
            !cr.preloadCryptoKeyForJid || !cr.scrambleJid) {
                throw new Error("At least one crypto function is not provided in 'options.crypto'");
        }
        j.encryptMessageForJid = cr.encryptMessageForJid;
        j.decryptMessage = cr.decryptMessage;
        j.generateMac = cr.generateMac;
        j.generateMacKey = cr.generateMacKey;
        j.preloadCryptoKeyForJid = cr.preloadCryptoKeyForJid;
        self.scrambleJid = cr.scrambleJid;
    }
    if (options.crypto && options.crypto.generateMacKey) {
        j.generateMacKey = options.crypto.generateMacKey;
    } else {
        j.generateMacKey = function() {
            var array = new Uint8Array(32);
            var result = '';
            window.crypto.getRandomValues(array);
            for (var i=0; i<32; i++)
                result+=String.fromCharCode(array[i]);
            return btoa(result);
        };
    }

    j.verifyMac = function(msg, key, actualMac) {
        if (!actualMac)
            return false;
        var expectedMac;
        try {
            expectedMac = j.generateMac(msg, key);
        } catch(e) {
            return false;
        }

        // constant-time compare
        var aLen = actualMac.length;
        var eLen = expectedMac.length;
        var match = (aLen === eLen);
        for (var i=0; i < Math.min(aLen, eLen); i++) {
            match &= (expectedMac.charCodeAt(i) === actualMac.charCodeAt(i));
        };
        return match;
    };
//===
    if (!options.iceServers) {
        console.warn("No default ice servers provided in options, you must set them before a call is started");
    } else {
        j.iceServers = options.iceServers;
    }
    self.options = options;
    self.audioMuted = false;
    self.videoMuted = false;
    self.PRANSWER = false; // use either pranswer or autoaccept

    j.rtcSession = self; //needed to access the RtcSession object from jingle event handlers
//muc stuff
    self.myroomjid = null;
    self.roomjid = null;
    self.list_members = [];
//===
    j.onConnectionEvent = self.onConnectionEvent;

    if (RtcSession.RAWLOGGING)
    {
        self.connection.rawInput = function (data)
        { if (RtcSession.RAWLOGGING) console.log('RECV: ' + data); };
        self.connection.rawOutput = function (data)
        { if (RtcSession.RAWLOGGING) console.log('SEND: ' + data); };
    }

    j.pc_constraints = RTC.pc_constraints;


    j.eventHandler = self; //all callbacks will be called with self == eventHandler
    j.onIncomingCallRequest = self.onIncomingCallRequest;
  /**
    Fired when the incoming call request is not longer valid. This may happen for the reasons stated below,
    and the reason is specified in the info.event property: <br>
    1) Cancened by caller. info.event='canceled' <br>
    2) Handled by another resource (i.e. client). info.event='handled-elsewhere' <br>
    3) Call was not handled by anybody for a certain time, <br>
      even without the caller sending a cancel message. info.event='timeout'
    @event "call-canceled"
    @type {object}
    @property {string} peer
        The full JID from which the call originated
    @property {object} info Additional details
    @property {string} info.event
        The reason why the call request is not valid anymore
    @property {boolean} [info.answered]
        Only if event='handled-elsewhere'. <i>true</i> if the call was answered by that other resource, of <i>false</i> if the call was declined by it
    @property {string} [info.by]
        Only if event='handled-elsewhere'. The full JID that handled the call
  */
    j.onCallCanceled = function(info) {
        self.trigger('call-canceled', info);
    };
    j.onCallAnswered = self.onCallAnswered.bind(self);
    j.onCallTerminated = self.onCallTerminated.bind(self);
    j.onRemoteStreamAdded = self.onRemoteStreamAdded.bind(self);
    j.onRemoteStreamRemoved = self.onRemoteStreamRemoved.bind(self);
    j.onNoStunCandidates = self.noStunCandidates.bind(self);
    j.onJingleError = self.onJingleError.bind(self);
    j.onMuted = (function(sess, info) {
    /**
    Fired when the remote peer muted a stream
    @event "muted"
    @type {object}
    @property {object} info
        @property {boolean} [info.audio] Present and equals to <i>true</i> if audio was muted
        @property {boolean} [info.video] Present and equals to <i>true</i> if video was muted
    @property {SessWrapper} sess
        The session on which the event occurred
    */
        self.trigger('muted', {info:info, sess: new SessWrapper(sess), peer: sess.peerjid});
    }).bind(self);
    j.onUnmuted = (function(sess, info) {
    /**
    Fired when the remote peer unmuted a stream
    @event "unmuted"
    @type {object}
    @property {object} info
        @property {boolean} [info.audio] Present and equals to <i>true</i> if audio was muted
        @property {boolean} [info.video] Present and equals to <i>true</i> if video was muted
    @property {SessWrapper} sess
        The session on which the event occurred
    */

        self.trigger("unmuted", {info:info, sess: new SessWrapper(sess), peer: sess.peerjid});
    }).bind(self);
}
//global variables
RtcSession.gVolMon = null;
RtcSession.gVolMonCallback = null;

RtcSession.prototype = {
    NO_DTLS: false, // compat with android
    _myGetUserMedia: function(options, successCallback, errCallback, allowContinueOnFail, sid) {
        var localMediaReqTimer = setTimeout(function() {
            self.trigger('local-media-request', {});
        }, 100);

        var self = this;
        if (self.gLocalStream) {
            var sessStream = RTC.cloneMediaStream(self.gLocalStream, {audio:true, video:true});
            if (options.video) {
                this._enableLocalVid(sid);
            }
            clearTimeout(localMediaReqTimer);
            self.trigger('local-media-handled', {});
            try {
                successCallback.call(self, sessStream);
            } catch (e) {
                self.jingle.onInternalError("_myGetUserMedia: exception in successCb()", {e:e});
            }
            return;
        }
//self.gLocalStream is null

        RTC.getUserMediaWithConstraintsAndCallback({audio: true, video: true})
        .catch(function(error) {
            console.warn("getUserMedia: Failed to get audio+video, trying audio-only...");
            return RTC.getUserMediaWithConstraintsAndCallback({audio: true, video: false});
        })
        .catch(function(error) {
            console.warn("getUserMedia: Failed to get audio only, trying video-only...");
            return RTC.getUserMediaWithConstraintsAndCallback({audio: false, video: true});
        })
        .catch(function(error) {
            clearTimeout(localMediaReqTimer);
            var msg;
            if (typeof error === 'string') {
                msg = error;
            } else if (error.name) {
                msg = error.name;
            } else if (error.code) {
                msg = error.code;
            } else {
                msg = error;
            }
            console.warn("getUserMedia: failed:", msg);
            self.trigger('local-media-handled', {});

            var failed = false;
            function fail() {
                failed = true;
                if (errCallback) {
                    errCallback(msg);
                }
            }
            if (!allowContinueOnFail) {
                fail();
                self.trigger('local-media-fail', {error: msg, sid: sid});
                return;
            }

            var obj = {
                error: msg,
                sid: sid,
                continue: function(cont) {
                    if (failed) {
                        throw new Error("Already handled by failure handler");
                    }
                    if (!cont) {
                        if (errCallback) {
                            errCallback(msg);
                        }
                    } else {
                        self._freeLocalStream(sid);
                        successCallback.call(self, null);
                    }
                }
            };
            /**
             Fired when there was an error getting the media stream from the local camera/mic
             @event "local-media-fail"
             @type object
             @property {string} error The error message
             @property {function(boolean)} [continue]
                If it is possible to continue without local media, this is a function
                that must be called with a bool argument to continue: either with
                aborting the call (if called with false),
                or continue the call (if called with true),
                but without any media stream sent by the local.
                IMPORTANT: For compatibility reasons, to use this function,
                a boolean property 'wait' must be set on the event's parameter object.
                Otherwise, the call will be aborted as if the function was called with false.
            */
            self.trigger('local-media-fail', obj);
            if (!obj.wait) {
                fail();
            }
        })
        .then(function(sessStream) {
            self.softAssert(sessStream, "getUserMedia returned null stream");
            console.log("getUserMedia: success");
            clearTimeout(localMediaReqTimer);
            self.trigger('local-media-handled', {});

            self._onMediaReady(sessStream, sid);
            if (options.video) {
                // we must call this after onMediaReady because it will enable
                // the local video display, and that is created in onMediaReady
                self._enableLocalVid(sid);
            }

            try {
                successCallback.call(self, sessStream);
            } catch (e) {
                self.jingle.onInternalError("_myGetUserMedia: Exception in stream obtained callback", {e:e});
            }
        });
    },

 onConnectionEvent: function(status, condition)
 {
//WARNING: called directly by Strophe, with this == connection.jingle
    switch (status)
    {
        case Strophe.Status.CONNFAIL:
        case Strophe.Status.DISCONNECTING:
        {
            this.rtcSession.hangupAll('xmpp-disconnect', null, true);
            break;
        }
        case Strophe.Status.CONNECTED:
        {
            this.rtcSession.ownAnonId = this.rtcSession.scrambleJid(
                Strophe.getBareJidFromJid(this.connection.jid))
                .replace(/[\/\+&<>@\?'"=]/gi, ''); //must be valid for xml attribute and url param

            this.connection.addHandler(RtcSession.prototype._onPresenceUnavailable.bind(this.rtcSession),
               null, 'presence', 'unavailable', null, null);
            break;
        }
    }
 },

/**
    Initiates a media call to the specified peer
    @param {string} targetJid
        The JID of the callee. Can be a full jid (including resource),
        or a bare JID (without resource), in which case the call request will be broadcast
        using a special <message> packet. For more details on the call broadcast mechanism,
        see the Wiki
    @param {MediaOptions} options Call options
        @param {boolean} options.audio Send audio
        @param {boolean} options.video Send video
    @param {string} [myJid]
        Necessary only if doing MUC, because the user's JID in the
        room is different than her normal JID. If not specified,
        the user's 'normal' JID will be used
    @returns {{sessionId: string, cancel: function()}}
        Returns an object with a cancel() method, that, when called, cancels the call request.
        This method returns <i>true</i> if the call was successfully canceled, and <i>false</i>
        in case the call was already answered by someone.
*/

 startMediaCall: function(targetJid, options, myJid)
 {
  var ansHandler = null;
  var declineHandler = null;
  var STATE_NO_USERMEDIA_YET = 0,
      STATE_GOT_USERMEDIA_WAIT_PEER = 1,
      STATE_PEER_ANS_OR_TIMEOUT = 2,
      STATE_CALL_CANCELED_BY_US = 4; //call was canceled by us via the cancel() method of the returned object
  var state = STATE_NO_USERMEDIA_YET;
  var self = this;
  var cancelCallRequest = null;
  var callRequest = null;
  var isBroadcast = (!Strophe.getResourceFromJid(targetJid));
  var ownFprMacKey = self.jingle.generateMacKey();
  var bin = new Uint8Array(40);
  window.crypto.getRandomValues(bin);
  var sid = self.ownAnonId+':'+btoa(String.fromCharCode.apply(null, bin)).substr(0, 16).replace('+', '-').replace('/', '_'); //Firefox's btoa(bin) seems to always return the same string
  var fileArr;
  var apiResponded = false;

  var initiateCallback = function(sessStream) {
      var actualAv = getStreamAv(sessStream);
      if ((options.audio && !actualAv.audio) || (options.video && !actualAv.video)) {
          console.warn("startMediaCall: Could not obtain audio or video stream requested by the user");
          if (!sessStream) {
              console.warn("...and stream is null");
          }
          options.audio = actualAv.audio;
          options.video = actualAv.video;
      }

      if (state === STATE_CALL_CANCELED_BY_US) {//call was canceled
          return;
      }
      state = STATE_GOT_USERMEDIA_WAIT_PEER;
      callRequest.fakeSession.localStream = sessStream;
// Call accepted handler
      ansHandler = self.connection.addHandler(function(stanza) {
          try {
              if ($(stanza).attr('sid') !== sid) {
                  return true;
              }
              if (state !== STATE_GOT_USERMEDIA_WAIT_PEER) {
                  return;
              }
              state = STATE_PEER_ANS_OR_TIMEOUT;
              // call request will be deleted by self.jingle.initiate() - there
              // may still be failure points from now till we reach there,
              // so we avoid having the call not listed anywhere in that period
              self.connection.deleteHandler(declineHandler);
              declineHandler = null;
              ansHandler = null;
              // The crypto exceptions thrown here will simply discard the call request and remove the handler
              var peerFprMacKey = $(stanza).attr('fprmackey');
              try {
                  peerFprMacKey = self.jingle.decryptMessage(peerFprMacKey);
                  if (!peerFprMacKey) {
                      peerFprMacKey = self.jingle.generateMacKey();
                  }
              } catch (e) {
                  peerFprMacKey = self.jingle.generateMacKey();
              }
              var peerAnonId = $(stanza).attr('anonid');
              if (!peerAnonId) {
                  throw new Error("No anonId in peer's call answer stanza");
              }
              callRequest.fakeSession.peerAnonId = peerAnonId;

              var fullPeerJid = $(stanza).attr('from');
              if (isBroadcast) {
                  self.connection.send($msg({
                      to:Strophe.getBareJidFromJid(targetJid),
                      type: 'megaNotifyCallHandled',
                      sid: sid,
                      by: fullPeerJid,
                      accepted:'1'
                  }));
              }

              var sess = self.jingle.initiate(sid, fullPeerJid,
                  myJid || self.connection.jid, sessStream,
                  sessStream
                      ? RtcSession.avFlagsToMutedState(options, sessStream)
                      : undefined,
                  {
                      ownFprMacKey: ownFprMacKey,
                      peerFprMacKey: peerFprMacKey,
                      peerAnonId: peerAnonId,
                      fileTransferHandler: options.files
                          ? self.jingle.ftManager.createUploadHandler(sid, fullPeerJid, fileArr)
                          : undefined
                  }
              );
              /**
              An outgoing call is being initiated by us
              @event "call-init"
              @type {object}
              @property {string} peer
                  The full JID of the remote peer, to whom the call is being made
              @property {object} peerMedia
                @property {object} sess The session object of the call
                @property {string} sid The session id of the call
                @property {boolean} isDataCall - true if this is a file transfer call
              */
              self.trigger('call-init', {
                  sess: new SessWrapper(sess),
                  peer:fullPeerJid,
                  sid: sid,
                  isDataCall: options.files ? true : false
              });
          } catch (e) {
              self._freeLocalStream(options.video, sid);
              self.jingle.onInternalError('Exception in call answer handler. Ignoring call', {sid: sid, e: e});
          }
      }, null, 'message', 'megaCallAnswer', null, targetJid, {matchBare: true});

//Call declined handler
      declineHandler = self.connection.addHandler(function(stanza) {
          try {
              if ($(stanza).attr('sid') !== sid) { // this message was not for us
                  return true;
              }
              if (state !== STATE_GOT_USERMEDIA_WAIT_PEER) {
                  return;
              }

              state = STATE_PEER_ANS_OR_TIMEOUT;
              delete self.jingle.callRequests[sid];
              self.connection.deleteHandler(ansHandler);
              ansHandler = null;
              declineHandler = null;
              sessStream = null;
              self._freeLocalStream(sid);

              var body = stanza.getElementsByTagName('body');
              var fullPeerJid = $(stanza).attr('from');

              if (isBroadcast) {
                  self.connection.send($msg({
                      to:Strophe.getBareJidFromJid(targetJid),
                      type: 'megaNotifyCallHandled',
                      sid: sid,
                      by: fullPeerJid,
                      accepted:'0'
                  }));
              }
              /**
               A call that we have initiated has been declined by the remote peer
               @event "call-declined"
               @type {object}
               @property {string} peer
                  The full JID of the peer that declined the call
               @property {string} reason
                  The short(one word) reason that the remote specified for declining the call.
                  If the remote user didn't explicitly specify one, the default is 'busy'
               @property {string} [text]
                  Optional verbose message specifying the reason
                  why the remote declined the call. Can be an error message
               @property {object} callOptions
               @property {boolean} isDataCall true if this is a file transfer call
               @property {string} sid - The session id of this call
              */
              self.trigger('call-declined', {
                  peer: fullPeerJid,
                  reason: $(stanza).attr('reason'),
                  sid: sid,
                  isDataCall: options.files ? true : false,
                  text : body.length ? RtcSession.xmlUnescape(body[0].textContent) : undefined,
                  callOptions: options
              });
          } catch (e) {
              self.jingle.onInternalError("Exception in call decline handler", {sid: sid, e: e});
          }
      }, null, 'message', 'megaCallDecline', null, targetJid, {matchBare: true});

      setTimeout(function() {
          if (!apiResponded) {
              cancelCallRequest(STATE_CALL_CANCELED_BY_US, "call-canceled", "api-timeout", "API request to load peer crypto pubkey timed out");
          }
      }, self.jingle.apiTimeout);

      self.jingle.preloadCryptoKeyForJid(function() {
          apiResponded = true;
          var msgattrs = {
              to: targetJid,
              type: 'megaCall',
              sid: sid,
              fprmackey: self.jingle.encryptMessageForJid(ownFprMacKey, targetJid),
              anonid: self.ownAnonId
          };
          if (options.files) {
              var infos = {};
              fileArr = [];
              var uidPrefix = sid+Date.now();
              var rndArr = new Uint32Array(4);
              crypto.getRandomValues(rndArr);
              for (var i=0; i<4; i++)
                  uidPrefix+=rndArr[i].toString(32);
              for (var i=0; i<options.files.length; i++) {
                  var file = options.files[i];
                  file.uniqueId = uidPrefix+file.name+file.size;
                  fileArr.push(file);
                  var info = {size: file.size, mime: file.type, uniqueId: file.uniqueId};
                  infos[file.name] = info;
              }
              msgattrs.files = JSON.stringify(infos);
          } else { //!options.files
              msgattrs.media = (options.audio?'a':'')+(options.video?'v':'');
              if (!msgattrs.media)
                  msgattrs.media = '_';
          }

          self.connection.send($msg(msgattrs));
      }, targetJid);

      if (!options.files) { //set answer timeout
          setTimeout(function() {
              if (state !== STATE_GOT_USERMEDIA_WAIT_PEER) {
                  return;
              }
              /**
              A call that we initiated was not answered (neither accepted nor rejected)
              within the acceptable timeout.
              Has the same data object as the one of call-ended,
              including stats
              @event "call-answer-timeout"
              @type {object}
             */
              cancelCallRequest(STATE_PEER_ANS_OR_TIMEOUT, 'call-answer-timeout', 'call-unanswered');
          }, self.jingle.callAnswerTimeout);
      } //end set answer timeout
  } //end initiateCallback()

  cancelCallRequest = function(newState, eventName, reason, text, errInfo) {
      if ((state === STATE_PEER_ANS_OR_TIMEOUT) || (state === STATE_CALL_CANCELED_BY_US)) {
          return false;
      }

      state = newState;
      delete self.jingle.callRequests[sid];

      if (state === STATE_GOT_USERMEDIA_WAIT_PEER) { //same as if (ansHandler)
          self.connection.deleteHandler(ansHandler);
          ansHandler = null;
          self.connection.deleteHandler(declineHandler);
          declineHandler = null;
      }
      self.connection.send($msg({
              to:Strophe.getBareJidFromJid(targetJid),
              sid: sid,
              reason: reason,
              text: text,
              type: 'megaCallCancel'
      }));
//temporary stats
      callRequest.fakeSession.apiResponded = apiResponded;
//===
      self.onCallTerminated(callRequest.fakeSession, reason, text, errInfo, eventName);
      return true;
  }

  callRequest = self.jingle.callRequests[sid] = {
         fakeSession: {
            fake: true,
            peerjid: targetJid,
            sid: sid,
            callOptions: options,
            isInitiator: true //peerAnonId is set when it is received, but may never be received
         },
         cancel: function(eventName, reason, text, errInfo) {
             return cancelCallRequest(STATE_CALL_CANCELED_BY_US, eventName, reason, text, errInfo);
         }
  }
  if (options.audio || options.video) {
      self._myGetUserMedia(options, initiateCallback, null, true, sid);
  } else {
      initiateCallback(null);
  }
  //return an object with a cancel() method
  return {
      sid: sid,
      cancel: function() {
          return callRequest.cancel('call-canceled', 'user'); //TODO: verify compat with callManager
      },
      callOptions: options
  };
 },

/** Terminates all current calls and file transfers */
hangupAll: function(reason, text)
{
    if (!reason) {
        reason = 'hangup';
    }

    var jingle = this.jingle;
    jingle.terminateAll(reason, text);
    for (var asid in jingle.acceptCallsFrom) {
        jingle.cancelAutoAnswerEntry(asid, reason, text);
    }
    for (var sid in jingle.callRequests) {
        jingle.callRequests[sid].cancel('call-canceled', reason, text);
    }
},
 /**
    Terminates an ongoing call or file transfer
    @param {string} sid The sid of the session to hangup.
    @returns {bool} true if the sid matched a call, false otherwsise
 */
 hangup: function(sid)
 {
    var j = this.jingle;
    var sess = j.sessions[sid];
    if (sess) {
        j.terminateBySid(sid, 'hangup');
        return true;
    }
    return (j.cancelAutoAnswerEntry(sid, 'hangup')) || (j.cancelCallRequest(sid, 'hangup'));
 },

 /**
    Mutes/unmutes audio/video
    @param {boolean} state
        Specifies whether to mute or unmute:
        <i>true</i> mutes,  <i>false</i> unmutes.
    @param {object} what
        Determine whether the (un)mute operation applies to audio and/or video channels
        @param {boolean} [what.audio] The (un)mute operation is applied to the audio channel
        @param {boolean} [what.video] The (un)mute operation is applied to the video channel
    @param {string} [jid]
        If given, specifies that the mute operation will apply only
        to the call to the given JID. If not specified,
        the (un)mute will be applied to all ongoing calls.
 */
    muteUnmute: function(state, what, jid) {
        var sessions = this._getSessionsForJid(jid);
        if (!sessions) {
            return false;
        }
        // If we are muting all calls, disable also local video playback as well
        // In Firefox, all local streams are only references to gLocalStream, so muting any of them
        // mutes all and the local video playback.
        // In Chrome all local streams are independent, so the local video stream has to be
        // muted explicitly as well
        for (var i = 0; i < sessions.length; i++) {
            var sess = sessions[i];
            if (what.video && this.gLocalVid) {
                if (state) { // mute
                    this._disableLocalVid(sess.sid); // does nothing if already disabled
                } else { // unmute
                    this._enableLocalVid(sess.sid); // does nothing if already enabled
                }
            }
            sess.muteUnmute(state, what);
        }
        return true;
    },
    _getSessionsForJid: function(jid) {
        var sessions = [];
        if (!jid) {
            for (var k in this.jingle.sessions) {
                sessions.push(this.jingle.sessions[k]);
            }
            if (sessions.length < 1) {
                return null;
            }
        } else {
            var isFullJid = (jid.indexOf('/') >= 0);
            for (var sid in this.jingle.sessions) {
                var sess = this.jingle.sessions[sid];
                if (isFullJid) {
                    if (sess.peerjid === jid) {
                        sessions.push(sess);
                    }
                } else {
                    if (Strophe.getBareJidFromJid(sess.peerjid) === jid) {
                        sessions.push(sess);
                    }
                }
            }
        }
        return sessions;
    },
    _onPresenceUnavailable: function(pres) {
        var from = $(pres).attr('from');
        var sessions = this.jingle.sessions;
        for (var sid in sessions) {
            var sess = sessions[sid];
            if (sess.peerjid === from) {
                this.jingle.terminate(sess, 'peer-xmpp-disconnect');
            }
        }
        return true; // We dont want this handler to be deleted
    },

    _onMediaReady: function(localStream, sid) {
        this.gLocalStream = localStream;
        for (var i = 0; i < localStream.getAudioTracks().length; i++) {
            console.log('using audio device "' +localStream.getAudioTracks()[i].label + '"');
        }
        for (i = 0; i < localStream.getVideoTracks().length; i++) {
            console.log('using video device "' + localStream.getVideoTracks()[i].label + '"');
        }
        // mute video on firefox and recent canary
        var elemClass = "localViewport";
        if (localStream.getVideoTracks().length < 1) {
            elemClass +=" localNoVideo";
        }
        this.softAssert(!this.gLocalVid, "Local stream just obtained, but gLocalVid was not null");

        var vid = $('<video class="'+elemClass+'" autoplay="autoplay" muted="muted" volume="0"/>');
        if (vid.length < 1) {
            throw new Error("Failed to create local video element");
        }

        vid = vid[0];
        vid.muted = vid.defaultMuted = true;
        vid.volume = 0;
        this.gLocalVid = vid;
        RTC.attachMediaStream(this.gLocalVid, this.gLocalStream);

        /**
        Local media stream has just been opened and a video element was
        created (the player param), but not yet added to the DOM. The stream object
        is a MediaStream interface object defined by the webRTC standard.
        This is the place to customize the player before it is shown. Also, this is the
        place to attach a mic volume callback, if used, via volMonAttachCallback().
        The callback will start being called just after the video element is shown.
        @event "local-stream-obtained"
        @type {object}
        @property {object} stream The local media stream object
        @property {DOM} player
        The video DOM element that displays the local video. <br>
        The video element will have the <i>localViewport</i> class.
        If the user does not have a camera, (only audio), the
        element will also have the localNoVideo CSS class.
        However, if the user has camera, event if he doesn't send video, local
        video will be displayed in the local player, and the local player will not have
        the <i>localNoVideo<i> class
        */
        this.trigger('local-stream-obtained', {stream: this.gLocalStream, player: vid});
        /**
        @event "local-stream-connect"
        @type {object}
        @property {object} player The local video element
        Fired when a call session connects to the local media stream, independent
        of whether the local stream has been just obtained or not, i.e. this
        event is always fired during a call setup
        */
        this.trigger('local-stream-connect', {player: vid});

        RtcSession._maybeCreateVolMon();
 },

    onIncomingCallRequest: function(params, ansFunc) {
        var self = this;
        /**
        Incoming call request received
        @event "call-incoming-request"
        @type {object}
        @property {object} params
          @property {string} peer
            The full JID of the caller
          @property {ReqValidFunc} reqStillValid
            A function returning boolean that can be used at any time to check if the call
            request is still valid (i.e. not timed out)
          @property {object} peerMedia
            @property {bool} audio
                Present and equal to true if peer enabled audio in his mediaOptions to startMediaCall()
            @property {bool} video
                Present and equal to true if peer enabled video
          @property {AnswerFunc} answer
            A function to answer or decline the call
        */
        params.answer = function(accept, obj) {
            if (!params.reqStillValid()) { // expired
                return false;
            }
            if (!accept) {
                return ansFunc(false, {
                    reason: obj.reason?obj.reason:'busy',
                    text: obj.text
                });
            }
            if (!params.files) {
                var media = obj.mediaOptions;
                self._myGetUserMedia(media,
                    function(sessStream) {
                        ansFunc(true, {
                            options: {
                                localStream: sessStream,
                                muted: RtcSession.avFlagsToMutedState(media, sessStream)
                            }
                        });
                    },
                    function(err) {
                        ansFunc(false, {
                            reason: 'error',
                            text: "There was a problem accessing user's camera or microphone. Error: "+err
                        });
                    },
                    // allow to answer with no media only if peer is sending something
                    (params.peerMedia.audio || params.peerMedia.video),
                    params.sid
                );
            } else {//file transfer
                ansFunc(true, {});
            }
            return true;
        };
        this.trigger('call-incoming-request', params);
        /**
        Function parameter to <i>call-incoming-request</i> to check if the call request is still valid
        @callback ReqValidFunc
        @returns {boolean}
        */

        /**
        Function parameter to <i>call-incoming-request</i> to answer or decline the call
        @callback AnswerFunc
        @param {boolean} accept Specifies whether to accept (<i>true</i>) or decline (<i>false</i>) the call
        @param {object} obj Options that depend on whether the call is to be acceped or declined
          @param {string} [obj.reason] If call declined: The one-word reason why the call was declined
            If not specified, defaults to 'busy'
          @param {string} [obj.text] If call declined: The verbose text explaining why the call was declined.
            Can be an error message
          @param {MediaOptions} [obj.mediaOptions] If call accepted: The same options that are used in startMediaCall()
        @returns {boolean}
            Returns <i>false</i> if the call request has expired, <i>true</i> otherwise
        */
    },

    onCallAnswered: function(info) {
        /**
        An incoming call has been answered
        @event "call-answered"
        @type {object}
        @property {string} peer The full JID of the remote peer that called us
       */
        this.trigger('call-answered', info);
    },

    removeVideo: function(sess) {
        /**
        The media session with peer JID has been destroyed, and the video element
            has to be removed from the DOM.
        @event "remote-player-remove"
        @type object
        @property {string} id The id of the html video element to be removed
        @property {string} peer The full jid of the peer
        @property {SessWrapper} sess
        */
        this.trigger('remote-player-remove', {
            id: '#'+this.vidIdFromSid(sess.sid),
            peer: sess.peerjid,
            sess:new SessWrapper(sess)
        });
    },

    onMediaRecv: function(playerElem, sess, stream) {
        if (!this.jingle.sessionIsValid(sess)) {
            this.error("onMediaRecv received for non-existing session:", sid)
            return;
        }
        /**
        Triggered when actual media packets start being received from <i>peer</i>,
        on session <i>sess</i>. The video DOM element has just been created, and is passed as the
        player property.
        @event "media-recv"
        @type {object}
        @property {string} peer The full JID of the peer
        @property {SessWrapper} sess The session
        @property {MediaStream} stream The remote media stream
        @property {DOM} player
        The video player element that has just been created for the remote stream.
        The element will always have the rmtViewport CSS class.
        If there is no video received, but only audio, the element will have
        also the rmtNoVideo CSS class.
        <br>NOTE: Because video is always negotiated if there is a camera, even if it is not sent,
        the rmt(No)Video is useful only when the peer does not have a camera at all,
        and is not possible to start sending video later during the call (for desktop
        sharing, the call has to be re-established)
       */
        var obj = {peer: sess.peerjid, sess:new SessWrapper(sess), stream: stream, player: playerElem};
        this.trigger('media-recv', obj);
        if (obj.stats || this.statsUrl) {
            if (typeof obj.stats !== 'object') {
                obj.stats = {scanPeriod: 1, maxSamplePeriod: 5};
            }
            if (RTC.Stats) {
                var s = obj.stats;
                if (!s.scanPeriod || !s.maxSamplePeriod) {
                    return;
                }
                sess.statsRecorder = new RTC.Stats.Recorder(sess, s.scanPeriod, s.maxSamplePeriod, s.onSample);
                sess.statsRecorder.start();
            } else {
                console.warn("RTC stats requested, but stats API not available on this browser");
            }
        }
        sess.tsMediaStart = Date.now();
    },

    onCallTerminated: function(sess, reason, text, errInfo, eventName) {
        try {
            // WARNING: sess may be a dummy object, only with peerjid property, in case something went
            // wrong before the actual session was created, e.g. if SRTP fingerprint verification failed

            /**
            Call was terminated, either by remote peer or by us
            @event "call-ended"
            @type {object}
            @property {string} peer The remote peer's full JID
            @property {SessWrapper} sess The session of the call
            @property {string} [reason] The reason for termination of the call
            @property {string} [text]
              The verbose reason or error message for termination of the call
            @property {object} [stats]
              The statistics gathered during the call, if stats were enabled
            @property {object} [basicStats]
              In case statistics are not available on that browser, or were not enabled,
              this property is set and contains minimum info about the call that can be
              used by a stats server
            @property {string} basicStats.callId
              The callId that the statistics engine would provide
            @property {number} basicStats.callDur
              The duration of actual media in seconds (ms rounded via Math.ceil()) that
              the stats engine would have provided
            */
            var self = this;
            var obj = {
                peer: sess.peerjid,
                sess: new SessWrapper(sess), // can be a dummy session but the wrapper will still work
                reason:reason,
                text:text
            };
            var trsn = ((eventName === 'call-canceled')?'cancel-':'')+reason;
            var stats;
            if (sess.statsRecorder)  {
                stats = obj.stats = sess.statsRecorder.terminate(sess.sid);
                if (sess.isInitiator) {
                    stats.isCaller = 1;
                    stats.caid = self.ownAnonId;
                    stats.aaid = sess.peerAnonId;
                } else {
                    stats.isCaller = 0;
                    stats.caid = sess.peerAnonId;
                    stats.aaid = self.ownAnonId;
                }
            } else { //no stats, but will still provide callId and duration
                stats = obj.basicStats = {
                    cid: sess.sid,
                    bws: stats_getBrowserVersion()
                };
                if (sess.isInitiator) {
                    stats.isCaller = 1;
                    stats.caid = self.ownAnonId;
                    stats.aaid = sess.peerAnonId;
                } else {
                    stats.isCaller = 0;
                    stats.caid = sess.peerAnonId;
                    stats.aaid = self.ownAnonId;
                }

                if (sess.fake) {
                    sess.me = this.jid; //just in case someone wants to access the own jid of the fake session
                }
                if (sess.tsMediaStart) {
                    stats.ts = Math.round(sess.tsMediaStart/1000);
                    stats.dur = Math.ceil((Date.now()-sess.tsMediaStart)/1000);
                }
            }
            stats.termRsn = trsn;
            if (text) {
                stats.termMsg = text;
            }
            if (errInfo) {
                stats.errInfo = errInfo;
            }
            if (sess.apiResponded !== undefined) {
                stats.apiresp = sess.apiResponded;
            }

            if (this.statsUrl)
                jQuery.ajax(this.statsUrl, {
                                type: 'POST',
                                data: JSON.stringify(stats)
                            });

            if (!eventName) {
                eventName = 'call-ended';
            }
            this.trigger(eventName, obj);

            // release local video
            var videoUsed;
            if (sess.fake) { // this is a fake session of a call request or auto-answer item
                this.softAssert(sess.callOptions, "onCallTerminated: Fake session without 'callOptions'");
                videoUsed = sess.callOptions.video;
            } else if (sess.localStream) {
                this.softAssert(sess.mutedState, "onCallTerminated: session with local stream must have a mutedState");
                var vt = sess.localStream.getVideoTracks();
                videoUsed = (vt.length > 0) && !sess.mutedState.videoMuted;
                delete sess.localStream;
            } else {
                videoUsed = false;
            }
            if (sess.remoteStream) {
                this.removeVideo(sess); //remove remote video
            }
            this._freeLocalStream(sess.sid);
        } catch (e) {
            this.jingle.onInternalError("onTerminate() handler threw an exception", {e:e});
        }
    },

    waitForRemoteMedia: function(playerElem, sess) {
        if (!this.jingle.sessionIsValid(sess)) {
            return;
        }
        var self = this;

        // Under Firefox < 4x, currentTime seems to stay at 0 forever,
        // despite that there is playback
        if ((playerElem.currentTime > 0) || (RTC.browser === "firefox")) {
            this.onMediaRecv(playerElem, sess, sess.remoteStream);
            RTC.attachMediaStream(playerElem, sess.remoteStream); // FIXME: why do i have to do this for FF?
        } else {
            setTimeout(function () { self.waitForRemoteMedia(playerElem, sess); }, 200);
        }
 },

    // onRemoteStreamAdded -> waitForRemoteMedia (waits till time>0) -> onMediaRecv() -> addVideo()
    onRemoteStreamAdded: function(sess, stream) {
        if ($(document).find('#'+this.vidIdFromSid(sess.sid)).length !== 0) {
            console.warn('Ignoring duplicate onRemoteStreamAdded for session', sess.sid); // FF 20
            return;
        }
        /**
        @event "remote-sdp-recv"
        @type {object}
        @property {string} peer The full JID of the peer
        @property {MediaStream} stream The remote media stream
        @property {SessWrapper} sess The call session
        */
        this.trigger('remote-sdp-recv', {peer: sess.peerjid, stream: stream, sess: new SessWrapper(sess)});
        var elemClass;
        var videoTracks = stream.getVideoTracks();
        if (!videoTracks || (videoTracks.length < 1)) {
            elemClass = 'rmtViewport rmtNoVideo';
        } else {
            elemClass = 'rmtViewport rmtVideo';
        }
        this._attachRemoteStreamHandlers(stream);
        // after remote stream has been added, wait for ice to become connected
        // old code for compat with FF22 beta
        var elem = $("<video autoplay='autoplay' class='"+elemClass+"' id='" + this.vidIdFromSid(sess.sid)+"' />");
        elem = elem[0];
        RTC.attachMediaStream(elem, stream);
        this.waitForRemoteMedia(elem, sess); //also attaches media stream once time > 0

        // does not yet work for remote streams -- https://code.google.com/p/webrtc/issues/detail?id=861
        //    var options = { interval:500 };
        //    var speechEvents = hark(data.stream, options);

        //    speechEvents.on('volume_change', function (volume, treshold) {
        //      console.log('volume for ' + sid, volume, treshold);
        //    });
    },

    onRemoteStreamRemoved: function(event) {
    },

    noStunCandidates: function() {
    },

    onJingleError: function(sess, err, stanza, orig) {
        if (err.source == 'transportinfo') {
            err.source = 'transport-info (i.e. webrtc ice candidate)';
        }
        if (!orig) {
            orig = "(unknown)";
        }

        if (err.isTimeout) {
            console.error('Timeout getting response to "'+err.source+'" packet, session:'+sess.sid+', orig-packet:\n', orig);
            /**
            @event "jingle-timeout"
            @type {object}
            @property {string} src A semantic name of the operation where the timeout occurred
            @property {DOM} orig The original XML packet to which the response timed out
            @property {SessWrapper} sess The session on which the timeout occurred
            */
            this.trigger('jingle-timeout', {src: err.source, orig: orig, sess: new SessWrapper(sess)});
        } else {
            if (!stanza) {
                stanza = "(unknown)";
            }
            console.error('Error response to "'+err.source+'" packet, session:', sess.sid,
                '\nerr-packet:\n', stanza, '\norig-packet:\n', orig);
            /**
             @event "jingle-error"
             @type {object}
             @property {string} src A semantic name of the operation where the error occurred
             @property {DOM} orig The XML stanza in response to which an error stanza was received
             @property {DOM} pkt The error XML stanza
             @property {SessWrapper} sess The session on which the error occurred
            */
            this.trigger('jingle-error', {src:err.source, pkt: stanza, orig: orig, sess: new SessWrapper(sess)});
        }
    },

    /**
     Get a SessWrapper object for a session, identified by the specified sid
     @param {string} sid The sid of the session
    */
    getSessionBySid: function(sid) {
        var sess = this.jingle.sessions[sid];
        if (!sess) {
            return null;
        }
        return new SessWrapper(sess);
    },

    /**
    Updates the ICE servers that will be used in the next call.
    @param {array} iceServers An array of ice server objects - same as the iceServers parameter in
          the RtcSession constructor
    */
    updateIceServers: function(iceServers) {
        if (!iceServers || (iceServers.length < 1)) {
             console.warn("updateIceServers: Null or empty array of ice servers provided");
        }
        this.jingle.iceServers = iceServers;
    },

    /**
    This is a <b>class</b> method (i.e. not called on an instance but directly on RtcSession).
    Registers a callback function that will be called
    repeatedly every 400 ms with the current mic volume level from 0 to 100%, once
    the local media stream is accessible. This can be called multiple times to change
    the callback, but only one callback is registered at any moment,
    for performance reasons.
    @static
    @param {VolumeCb} cb
        The callback function

   */
    volMonAttachCallback: function(cb)
    {
        RtcSession.gVolMonCallback = cb;
    },

    /**
    The volume level callback function
    @callback VolumeCb
    @param {int} level - The volume level in percent, from 0 to 100
    */
    _attachRemoteStreamHandlers: function(stream)
    {
        /* We currently get remote stream mute events over jingle, not over webrtc
        var self = this;
        var at = stream.getAudioTracks();
        for (var i=0; i<at.length; i++)
            at[i].onmute = function(e) {
                self.trigger('remote-audio-muted', stream);
            };
        var vt = stream.getVideoTracks();
        for (var i=0; i<vt.length; i++)
            vt[i].onmute = function(e) {
                self.trigger('remote-video-muted', stream);
            };
        */
    },
    _freeLocalStream: function(sid) {
        if (!this.gLocalStream) {
            return;
        }
        RTC.stopMediaStream(this.gLocalStream);
        this._disableLocalVid(sid);

        /**
        Local stream is about to be closed and local video player to be destroyed
        @event local-video-destroy
        @type {object}
        @property {DOM} player The local video player, which is about to be destroyed
        */
        if (this.gLocalVid) {
            this.trigger('local-player-remove', {player: this.gLocalVid, sid: sid});
            this.gLocalVid = null;
        } else {
            this.logMsg('w', "_freeLocalStream: this.gLocalVid is null: would have triggered assertion in CallManager before this fix. Stack:\n"+new Error().stack);
        }

        this.gLocalStream = null;
    },
    _disableLocalVid: function(sid) {
        if (!this._localVidEnabled) {
            return;
        }
        // All references to local video are muted, disable local video display
        // We need sid only to have where an object to trigger the event on
        RTC.attachMediaStream(this.gLocalVid, null);
        this._localVidEnabled = false;

        /**
        Local camera playback has been disabled because all calls have muted their video
        @event local-video-disabled
        @type {object}
        @property {DOM} player - the local camera video HTML element
        */
        this.trigger('local-video-disabled', {player: this.gLocalVid, sid: sid});
    },
    _enableLocalVid: function(sid) {
        // need sid only to trigger the event on the proper session
        if (this._localVidEnabled) {
            return;
        }
    /**
        Local video playback has been re-enabled because at least one call started sending video
        @event local-video-enabled
        @type {object}
        @property {DOM} player The local video player HTML element
    */
        this.trigger('local-video-enabled', {player: this.gLocalVid, sid: sid});
        this.gLocalVid.play();
        this._localVidEnabled = true;
    },

    trigger: function(name, obj) {
        console.warn("webRTC event:",name, obj);
        if (this.logEvent) {
            this.logEvent(name, obj);
        }
        try {
            $(this).trigger(name, [obj]);
        } catch (e) {
        this.jingle.onInternalError("Exception thrown from user event handler '"+name+"'", {e:e});
        }
    },
    softAssert: function(cond) {
        if (cond) {
            return;
        }
        var last = arguments.length-1;
        var msg = '';
        for (var i = 1; i <= last; i++) {
            msg += arguments[i];
            if (i < last) {
                msg += ' ';
            }
        }

        var e = new Error(msg); //we need the stack
        this.jingle.onInternalError("Soft Assertion failed", {e:e});
    },
    /**
    Releases any global resources referenced by this instance, such as the reference
    to the local stream and video. This should be called especially if multiple instances
    of RtcSession are used in a single JS context
    */
    destroy: function() {
        this.hangup();
    },
    /** generates a dom id for a remote video element for given session id */
    vidIdFromSid: function(sid) {
        if (!sid) {
            throw new Error("vidIdFromSid: sid is undefined");
        }
        return "remotevideo_"+sid.substring(0, 10);
    },

    /** Returns whether the call or file transfer with the given
        sessionId is being relaid via a TURN server or not.
      @param {string} sid The session id of the call
      @returns {integer} 1 if the call/transfer is being relayed, 0 if not, 'undefined' if the
        status is unknown (not established yet or browser does not provide stats interface)
    */
    isRelay: function(sid) {
        var sess = this.jingle.sessions[sid];
        if (!sess || ! sess.statsRecorder) {
            return undefined;
        }
        return sess.statsRecorder.isRelay();
    },

    onInternalError: function(msg, info) {
        info.msg = msg;
        this.logMsg('e', info);
    },

    logMsg: function(type, data) {
        if (window._testing) {
            var confunc;
            if (type === 'e') {
                confunc = 'error';
            } else if (type === 'w') {
                confunc = 'warn';
            } else {
                confunc = 'log';
            }
            console[confunc].call(console, "logMsg:", JSON.stringify(data));
            return;
        }
        if (typeof data !== 'object') {
            data = {data: data};
        }
        data.client = RTC.browser;
        var wait = 500;
        var retryNo = 0;
        var self = this;
        function req() {
            jQuery.ajax("https://stats.karere.mega.nz/msglog?aid="+self.ownAnonId+"&t="+type, {
                type: 'POST',
                data: JSON.stringify(data),
                error: function(jqXHR, textStatus, errorThrown) {
                    retryNo++;
                    if (retryNo < 20) {
                        wait *= 2;
                        setTimeout(function() {
                            req();
                        }, wait);
                    }
                },
                dataType: 'json'
            });
        }
        req();
    }
}

RtcSession._maybeCreateVolMon = function() {
    if (RtcSession.gVolMon) {
        return true;
    }
    if (!RtcSession.gVolMonCallback || (typeof hark !== "function")) {
        return false;
    }

    RtcSession.gVolMon = hark(RtcSession.gLocalStream, { interval: 400 });
    RtcSession.gVolMon.on('volume_change',
        function (volume, treshold)
        {
         //console.log('volume', volume, treshold);
            var level;
            if (volume > -35) {
                level = 100;
            } else if (volume > -60) {
                level = (volume + 100) * 100 / 25 - 160;
            } else {
                level = 0;
            }
            RtcSession.gVolMonCallback(level);
        });
    return true;
}

RtcSession.avFlagsToMutedState =  function(flags, stream) {
    if (!stream)
        return {audio:true, video:true};
    var mutedState = new MutedState;
    var muteAudio = (!flags.audio && (stream.getAudioTracks().length > 0));
    var muteVideo = (!flags.video && (stream.getVideoTracks().length > 0));
    mutedState.set(muteAudio, muteVideo);
    return mutedState;
}

RtcSession.xmlUnescape = function(text) {
    return text.replace(/\&amp;/g, '&')
               .replace(/\&lt;/g, '<')
               .replace(/\&gt;/g, '>')
               .replace(/\&apos;/g, "'")
               .replace(/\&quot;/g, '"');
}

/**
 Anonymizes a JID
*/
RtcSession._anonJid = function(jid) {
    return MD5.hexdigest(Strophe.getBareJidFromJid(jid)+"webrtc stats collection");
}

/**
    Session object
    This is an internal object, but the following properties are useful for the library user.
    @constructor
*/
function SessWrapper(sess) {
    this._sess = sess;
}

SessWrapper.prototype = {

/**
    The remote peer's full JID
    @returns {string}
*/
peerJid: function() {
    return this._sess.peerjid;
},

/**
    Our own JID
    @returns {string}
*/
jid:function() {
    return this._sess.jid;
},

/**
  The stream object of the stream received from the peer
    @returns {MediaStream}
*/
remoteStream: function() {
    return this._sess.remoteStream;
},

/**
    The Jingle session ID of this session
    @returns {string}
*/
sid: function() {
    return this._sess.sid;
},

/**
    True if we are the caller, false if we answered the call
    @returns {boolean}
*/
isCaller: function() {
    return this._sess.isInitiator;
},

/**
    True if this is a dummy session object and there was no established session before
    the call ended, or the session was closed before emitting the event.
    The object's peerJid() and isCaller() methods are guaranteed to return
    a meaningful value, sid() may or may not return a session id. The other
    getters will return <i>undefined</i>.
    This type of dummy session is passed only to the call-ended
    event handler, and this happens when an error occurred. The reason and text
    event properties carry more info about the error
*/
isFake: function() {
    return (this._sess.isFake === true);
},

/** Returns whether a call or file transfer is being relayed through a TURN server or not.
      @returns {integer} If the status in unknown (not established yet or no stats
         provided by browser, e.g. Firefox), the return value is 'undefined', otherwise
         it is 0 if call is direct and 1 if call is relayed
*/
isRelay: function() {
    var statsRec = this._sess.statsRecorder;
    if (!statsRec)
        return undefined;
    else
        return statsRec.isRelay();
},
/**
    Get info whether local audio and video are being sent at the moment in that session
    @returns {{audio: Boolean, video: Boolean}} If the session is fake, null is returned
*/
sentMediaTypes: function()
{
    var sess = this._sess;
    if (sess.isFake) {
        return null;
    }
    var localStream = sess.localStream;
    if (!sess.localStream) {
        return { audio: false, video: false};
    }

   //we don't use sess.mutedState because in Forefox we don't have a separate
   //local streams for each session, so (un)muting one session's local stream applies to all
   //other sessions, making mutedState out of sync
    var audTracks = localStream.getAudioTracks();
    var vidTracks = localStream.getVideoTracks();
    return {
        audio: (audTracks.length > 0) && audTracks[0].enabled,
        video: (vidTracks.length > 0) && vidTracks[0].enabled
    }
},

/**
    Get info whether remote audio and video are being received at the moment in that session
    @returns {{audio: Boolean, video: Boolean}} If the session is fake, null is returned
*/
receivedMediaTypes: function() {
    var sess = this._sess;
    if (sess.isFake) {
        return null;
    }
    var remoteStream = sess.remoteStream;
    if (!remoteStream) {
        return {audio: false, video: false};
    }

    var m = sess.remoteMutedState;
    return {
        audio: (remoteStream.getAudioTracks().length > 0) && !m.audioMuted,
        video: (remoteStream.getVideoTracks().length > 0) && !m.videoMuted
    }
},
}

function getStreamAv(stream) {
    if (!stream) {
        return {audio:false, video: false};
    }
    var result = {};
    result.audio = (stream.getAudioTracks().length > 0);
    result.video = (stream.getVideoTracks().length > 0);
    return result;
}

var ctor = RtcSession.NotSupportedError = function(message) {
    this.message = message;
    // Use V8's native method if available, otherwise fallback
    if ("captureStackTrace" in Error)
        Error.captureStackTrace(this, InvalidArgumentException);
    else
        this.stack = (new Error()).stack;
}

var ctorPrototype = ctor.prototype;
ctorPrototype = ctor.prototype = Object.create(Error.prototype);
ctorPrototype.name = "NotSupportedError";
ctorPrototype.constructor = ctor;

RtcSession.xorEnc = function(str, key) {
  var int2hex = ['0','1','2','3','4','5','6','7','8','9','a','b','c','d','e','f'];

  var result = "";
  var j = 0;
  var len = str.length;
  var keylen = key.length;
  for (var i = 0; i < len; ++i) {
      var code = str.charCodeAt(i) ^ key.charCodeAt(j++);
      if (j >= keylen)
          j = 0;
      result+=int2hex[code>>4];
      result+=int2hex[code&0x0f];
  }
  return result;
}

RtcSession.xorDec = function(str, key) {
    var result = "";
    var len = str.length;
    var j = 0;
    if (len & 1)
        throw new Error("Not a proper hex string");
    var keylen = key.length;
    for (var i=0; i<len; i+=2) {
        var code = (RtcSession.hexDigitToInt(str.charAt(i)) << 4)|
            RtcSession.hexDigitToInt(str.charAt(i+1));
        code ^= key.charCodeAt(j++);
        if (j >= keylen)
            j = 0;
        result+=String.fromCharCode(code);
    }
    return result;
}

RtcSession.hexDigitToInt = function(digit) {
    var code = digit.charCodeAt(0);
    if (code > 47 && code < 58)
        return code-48;
    else if (code > 96 && code < 103)
        return code-97+10;
    else if (code > 64 && code < 71)
        return code-65+10;
    else
        throw new Error("Non-hex char");
};

