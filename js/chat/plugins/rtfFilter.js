/**
 * Rich text formatting filter (e.g. markdown-like rich text formatting when parsing text messages)
 *
 * @param megaChat
 * @returns {RtfFilter}
 * @constructor
 */
var RtfFilter = function(megaChat) {
    var self = this;

    self.regexps = {};
    self.regexps['(^|\\s)\\*{1,2}([^\\*\\n]{1,})\\*{1,2}'] = ['$1<strong>$2</strong>', '$1 $2'];
    self.regexps['(^|\\s)_{1,2}([^_\\n]{1,})_{1,2}'] = ['$1<em class="rtf-italic">$2</em>', '$1 $2'];
    self.regexps['(^|\\s)`{1}([^`\\n]{1,})`{1}'] = ['$1<pre class="rtf-single">$2</pre>', '$1 $2'];
    self.regexps['(^|\\s)`{3}(\n?)([^`]{1,})`{3}'] = ['$1<pre class="rtf-multi">$3</pre>', '$1 $3'];


    megaChat.bind("onBeforeRenderMessage", function(e, eventData) {
        self.processMessage(e, eventData);
    });

    return this;
};


RtfFilter.prototype.processStripRtfFromMessage = function(msg) {
    var self = this;
    Object.keys(self.regexps).forEach(function(regexp) {
        var replacement = self.regexps[regexp];
        msg = msg.replace(new RegExp(regexp, "gi"), replacement[1]);
    });
    return msg;
};

RtfFilter.prototype.processMessage = function(e, eventData) {
    var self = this;

    if (eventData.message.decrypted === false) {
        return;
    }


    // ignore if emoticons are already processed
    if (!eventData.message.processedBy) {
        eventData.message.processedBy = {};
    }
    if (eventData.message.processedBy['rtfFltr'] === true) {
        return;
    }

    // use the HTML version of the message if such exists (the HTML version should be generated by hooks/filters on the
    // client side.
    var textContents;
    if (eventData.message.textContents) {
        textContents = eventData.message.textContents;
    } else {
        return; // not yet decrypted.
    }


    var messageContents = eventData.message.messageHtml ? eventData.message.messageHtml : textContents;

    if (!messageContents) {
        return; // ignore, maybe its a system message (or composing/paused composing notification)
    }


    messageContents = messageContents ? $.trim(messageContents) : "";
    messageContents = messageContents.replace(/\<br\/\>/gi, '\n');
    Object.keys(self.regexps).forEach(function(regexp) {
        var replacement = self.regexps[regexp];
        messageContents = messageContents.replace(new RegExp(regexp, "gi"), replacement[0]);
    });
    messageContents = messageContents.replace(/\n/gi, "<br/>");
    eventData.message.messageHtml = messageContents;
    eventData.message.processedBy['rtfFltr'] = true;

    return messageContents;
};
