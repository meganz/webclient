<div class="privacy-top-bg ltr">
  <div class="privacy-top-pad">
    <h1>Developers</h1>
  </div>
</div>
<div class="account-mid-block dev-block ltr">
  <div class="main_bg_image">
    <div class="register-mid-pad">
      <div class="account-left-block">
        <a class="account-link selected clickurl" href="/dev" id="a_dev">
          <span class="account-link-arrow"></span>
          <span class="dev-new-icon dev-new-home">Home</span>
        </a>
        <a class="account-link clickurl" href="/sdk" id="a_dev_sdk">
          <span class="account-link-arrow"></span>
          <span class="dev-new-icon dev-new-core">C++ SDK</span>
        </a>
        <a class="account-link clickurl" href="/doc" id="a_dev_doc">
          <span class="account-link-arrow"></span> <span class="dev-new-icon dev-new-doc">Documentation</span>
        </a>
        <div class="dev-new-submenu hidden"><a class="dev-new-submenu-item"> <span class="dev-new-submenu-pad"> <span
                class="dev-new-submenu-txt" id="docmenu_1"> Preface </span> </span> </a> <a
                class="dev-new-submenu-item"> <span class="dev-new-submenu-pad"> <span class="dev-new-submenu-txt"
                                                                                       id="docmenu_5"> Programming model </span> </span>
        </a> <a class="dev-new-submenu-item"> <span class="dev-new-submenu-pad"> <span class="dev-new-submenu-txt"
                                                                                       id="docmenu_6"> Implementation </span> </span>
        </a> <a class="dev-new-submenu-item last"> <span class="dev-new-submenu-pad"> <span class="dev-new-submenu-txt"
                                                                                            id="docmenu_7"> Development process </span> </span>
        </a> <a class="dev-new-submenu-item last"> <span class="dev-new-submenu-pad"> <span class="dev-new-submenu-txt"
                                                                                            id="docmenu_8"> Planned future enhancements </span> </span>
        </a> <a class="dev-new-submenu-item last"> <span class="dev-new-submenu-pad"> <span class="dev-new-submenu-txt"
                                                                                            id="docmenu_9"> Method/callback overview </span> </span>
        </a> <a class="dev-new-submenu-item last"> <span class="dev-new-submenu-pad"> <span class="dev-new-submenu-txt"
                                                                                            id="docmenu_10"> Error codes </span> </span>
        </a> <a class="dev-new-submenu-item last"> <span class="dev-new-submenu-pad"> <span class="dev-new-submenu-txt"
                                                                                            id="docmenu_11"> Under the hood </span> </span>
        </a></div>
        <div class="clear"></div>
      </div>
      <div class="account-right-block">
        <div class="account-mid-pad">
          <div class="account-right-bg"></div>
          <div class="dev-new-pad" id="dev_start">
            <h1>MEGA SOFTWARE DEVELOPMENT KIT</h1>
            <div class="dev-new-left-bl">
              <div class="dev-new-img-bl"> <img alt="" src="{staticpath}images/mega/dev-img1.png" /> </div>
              <div class="dev-new-header"> C++ Client Access Engine </div>
              <div class="dev-new-description"> The software layer that shields your application from the complexities of MEGA's cryptography, API and I/O. </div>
              <a class="dev-new-red-button clickurl" href="/sdk"> Get the Code</a>
              <div class="clear"></div>
            </div>
            <div class="dev-new-right-bl">
              <div class="dev-new-img-bl"> <img alt="" src="{staticpath}images/mega/dev-img2.png" /> </div>
              <div class="dev-new-header"> Documentation </div>
              <div class="dev-new-description"> Getting started: Integration guide, data structures, methods and callbacks, error codes, and more! </div>
              <a class="dev-new-red-button clickurl" href="/doc"> View documentation</a>
              <div class="clear"></div>
            </div>
            <div class="clear"></div>
          </div>
          <div id="dev_sdk">
            <div class="dev-new-core-block image"> <img alt="" src="{staticpath}images/mega/dev-img1.png"  />
              <h2>Introduction</h2>
              <p>Welcome to the MEGA SDK for C++, providing essential abstraction to your application's secure cloud storage access.</p>
              <div class="clear"></div>
            </div>
            <div class="dev-new-core-div"></div>
            <div class="dev-new-core-block">
              <h2>Download</h2>
              <div class="clear"></div>
              <a href="https://github.com/meganz/sdk" class="dev-new-red-button" target="_new"> Browse SDK repository</a>
              <div class="clear"></div>
            </div>
            <div class="dev-new-core-div"></div>
            <div class="dev-new-core-block">
              <h2>Key Management</h2>
              <p>Each MEGA client application needs a valid key to access the API. Please use a separate key for each of your applications.</p>
              <div class="clear"></div>
              <a class="dev-new-red-button" id="dev_createapbtn"> Create an App</a>
              <div class="clear"></div>
            </div>
            <div class="dev-new-core-block">
              <div class="dev-new-table-block">
                <h2>Your apps</h2>
                <table width="100%" border="0" cellspacing="0" cellpadding="0" class="account-table" id="sdk_appstable">
                  <tr>
                    <th scope="col">App Name</th>
                    <th scope="col">Key</th>
                    <th scope="col">Status</th>
                    <th scope="col" class="last"></th>
                  </tr>
                </table>
              </div>
            </div>
          </div>
          <div id="dev_app">
            <div class="dev-new-top-block">
              <h1 id="sdk_apptitle"></h1>
              <a class="dev-new-delete">Delete App</a>
              <div class="clear"></div>
            </div>
            <div class="dev-new-core-div app-header"></div>
            <div class="dev-new-app-block">
              <div class="dev-new-app-left-txt">App Name</div>
              <div class="dev-new-input-block">
                <input value="App 1.0" id="sdk_appname"  />
              </div>
              <div class="clear"></div>
              <div class="dev-new-app-left-txt">App Status</div>
              <div class="dev-new-app-right-txt red-color" style="padding-top:2px;">
                <div class="radioOn" id="a_landing_rad1_div">
                  <input type="radio" name="rad1" id="a_landing_rad1" class="radioOn" value="1" checked>
                </div>
                <div class="radio-txt">In development</div>
                <div class="radioOff" id="a_landing_rad2_div">
                  <input type="radio" name="rad1" id="a_landing_rad2" class="radioOff" value="2">
                </div>
                <div class="radio-txt">In operation</div>
              </div>
              <div class="clear"></div>
              <div class="dev-new-app-left-txt">App Key</div>
              <div class="dev-new-app-right-txt" id="sdk_appkey"></div>
              <div class="clear"></div>
              <div class="dev-new-app-left-txt">Website</div>
              <div class="dev-new-input-block">
                <input value="" id="sdk_appsite"  />
              </div>
              <div class="clear"></div>
              <div class="dev-new-app-left-txt">Description</div>
              <div class="dev-new-input-block textarea">
                <textarea id="sdk_appdescription"></textarea>
              </div>
              <div class="clear"></div>
              <div class="dev-new-app-left-txt">Publisher Name</div>
              <div class="dev-new-input-block">
                <input value="ACME Inc." id="sdk_apppublisher" />
              </div>
              <div class="clear"></div>
              <div class="dev-new-app-buttons"> <a class="dev-core-button" id="sdkapp_updatebtn">Update</a> <a class="dev-core-button gray" id="sdkapp_cancelbtn">Cancel</a>
                <div class="clear"></div>
              </div>
            </div>
          </div>
          <div class="dev-block-pad new-dev" id="dev_doc" style="display:none;">
            <div id="dev_preface_div">
              <p>Welcome to the MEGA SDK! We hope that it will prove useful to developers who are interested in
                integrating MEGA support into their applications.</p>
              <h2 id="doc_1">1 What is the MEGA SDK good for?</h2>
              <p>The MEGA SDK consists of code and documentation that enables you to make use of MEGA's API
                functionality at a comfortably high level of abstraction. Its core component &mdash; a code module
                called <i>client access engine</i> &mdash; maintains a current copy of the user's account in memory
                (which includes all relevant files, folders, contacts and shares), accepts commands from the
                application and notifies the application of command results and other updates through callbacks.</p>
              <h2>2 How do I use the MEGA client access engine?</h2>
              <p>The MEGA client access engine comes as a set of C++ classes and interfaces. If you are using C++, you
                can simply add them to your project. You then instantiate the MegaClient class (which holds the session
                state) and pass it an instance of your implementation of the HttpIO interface (which handles network
                requests and blocking) and MegaApp (through which you receive the engine's callbacks).</p>
              <p>The core code is reasonably platform independent (if you encounter any issues with your specific C++
                compiler environment, please let us know). To illustrate practical usage, a sample application (a basic
                ftp-style interactive console client) is included.</p>
              <h2>3 Why do you provide a code module rather than documenting the API interface in sufficient detail for
                me to implement it myself?</h2>
              <p>Two reasons:</p>
              <ul>
                <li>Complexity/efficiency &mdash; Since all of MEGA's crypto logic runs on the client side, you'd be
                  looking at a project exceeding 5,000 lines of code. And, as natural language is rather inefficient
                  when it comes to specifying algorithms, the documentation would be similarly voluminous.
                </li>
                <li>Consistency/interoperability &mdash; Ambiguities in the specification or its imprecise
                  interpretation would inevitably lead to undesired behavioural differences between implementations.
                </li>
              </ul>
              <h2>4 Thanks, but why C++? I am using C, Objective C, C#, Java, Scala, Python, Ruby, Perl, PHP,
                VB...</h2>
              <p>The requirement to integrate with projects that compile to native code rules out all languages that
                rely on specific interpreters or runtime environments. C, being the "lingua franca" of nearly all
                modern systems, would have been the obvious choice, but the code compactness and readability benefits
                provided by C++'s syntactic sugar and template library are well worth the minor additional integration
                overhead. We will work with interested developers to add MEGA support to their preferred environments
                by way of native code modules/extensions (rather than by porting the functionality to the target
                language itself). Please contact us at <a href="mailto:developers@mega.nz">developers@mega.nz</a> if
                you are willing and able to contribute to a particular integration effort.</p>
              <h2 id="doc_5">5. Programming model</h2>
              <h2>5.1 Interaction</h2>
              <p>The application submits requests to the client access engine through nonblocking calls to methods of
                the MegaClient object and signals events to the application by invoking methods of an object of its
                implementation of the MegaApp interface.</p>
              <h2>5.2 Files and folders</h2>
              <p>Files and folders are represented by Node objects and referenced by node handles. Nodes point to
                parent nodes, forming trees. Trees have exactly one root node (circular linkage is not allowed). Node
                updates (caused by the session's own actions, other sessions of the same account or other accounts,
                e.g. through activity in a shared folder) are notified in real time through a callback specifying the
                affected nodes. Deleted nodes are first notified with their removed flag set before being purged to
                give the application an opportunity to remove them from the UI view.</p>
              <p>There are at least three node trees per account: Root, incoming and rubbish. Additional trees can
                originate from other users as shared folders.</p>
              <h2>5.3 Users and contacts</h2>
              <p>Users are referenced by their user handle and/or their primary e-mail address. The engine maintains a
                User object for every user account that has appeared in the context of the current session: As a
                contact or merely as the owner of a filesystem node. A visibility flag turns a user into a contact if
                set.</p>
              <p>User attributes can be used to store credentials such as avatar pictures, address, date of birth etc.
                It is recommended to store application-private user credentials AES-CBC encrypted.</p>
              <h2>5.4 Asynchronous completion</h2>
              <p>All engine methods are nonblocking &mdash; waiting for network communication to complete is not an
                option. Instead, they merely initiate the desired action, the outcome of which is eventually signalled
                through a callback. The application should be robust against such callbacks arriving after a long time
                (i.e., many seconds). Failed requests (e.g. due to network issues) are retried automatically with
                exponential backoff. The application receives notification of this through a callback and should inform
                the user accordingly, along with a UI element to manually initiate a retry.</p>
              <p>Three types of operation are subject to acceleration by a mechanism called "speculative instant
                completion": Node attribute updates, moves and deletions. As these merely receive a highly predictable
                "OK" or "failure" response from the API, there is some benefit in immediately updating the local nodes
                and reloading the session state in the rare event of an inconsistency. The engine loosely protects them
                with an access check that is following the same semantics as the authoritative check on the API server
                side.</p>
              <h2>5.5 Concurrency considerations</h2>
              <p>Shared access to a resource (writable nodes accessible to the user's account) based on a potentially
                outdated (due to network latency) view is naturally prone to race conditions, leading to
                inconsistencies when two parties make conflicting updates within the latency window. The engine
                contains heuristics to detect these conflicts and will ask the application to discard and reload its
                view if needed (the user should be informed accordingly).</p>
              <h2>5.6 Event processing and threading</h2>
              <p>Due to its nonblocking nature, the MEGA client access engine integrates extremely well with
                single-threaded applications (although on platforms without a nonblocking DNS lookup facility, you may
                not get around using a worker thread for name resolution). If you, however, prefer to use multiple
                threads, you are welcome to do so - as long as you ensure that no two threads get to enter the engine
                or access its data structures at the same time.</p>
              <h2>5.7 Running the engine</h2>
              <p>There are three approaches to integrating the engine with the application. The goal is to have the
                engine get the CPU (through MegaClient's exec() method) swiftly whenever one of its wakeup triggers
                fires: </p>
              <ul>
                <li>block inside the engine's own blocking callback (which waits for socket I/O and timeouts) and
                  include the application's own wakeup triggers
                </li>
                <li>record the engine's wakeup triggers and include them in the application's existing blocking
                  facility
                </li>
                <li>dedicate a worker thread to the MEGA engine and interact with the application through e.g. a
                  bidirectional message queue (inefficient, but the only option if, for some reason, you cannot modify
                  the application's event processing)
                </li>
              </ul>
              <h2>5.8 File name conflicts</h2>
              <p>Applications must be prepared to deal with file and folder name clashes. In many scenarios, this is
                trivial - the user sees all copies and makes the decision which file he is interested in, mostly based
                on its timestamp. Some applications, however, map a MEGA node tree to a resource that uses file paths
                as unique keys, e.g. filesystems. In this case, we recommend that only the most recent node is
                used.</p>
              <p>Filename characters that are not allowed on the host must be urlencoded using %xx. When writing files
                back to the server, valid urlencoded sequences must be replaced with the encoded character. This has
                the potential unwanted side effect of mangling filenames that originally contained valid %xx sequences,
                but this should be rare, and they'll be unmangled when read back to the local machine.</p>
              <h2>5.9 Namespace management: Node, file and user attributes</h2>
              <p>We kindly ask all application developers wishing to introduce new node, file or user attributes to
                coordinate the numbering/naming and formatting conventions with us to maximize cross-application
                interoperability. Should you elect not to do so, please avoid cluttering the namespaces and prefix the
                new attribute names with your abbreviated company or application name.</p>
              <h2 id="doc_6">6. Implementation</h2>
              <h2>6.1 Interfaces</h2>
              <p>The following interfaces need to be implemented by the application: </p>
              <ul>
                <li>
                  <c>FileAccess</c>
                  - File opening/closing/reading/writing
                </li>
                <li>
                  <c>HttpIO</c>
                  - HTTP requests with SSL support
                </li>
                <li>
                  <c>PrnGen</c>
                  - Cryptographically strong pseudo-random number generator</li>
                <li>
                  <c>SymmCipher</c>
                  - AES cryptography</li>
                <li>
                  <c>AsymmCipher</c>
                  - RSA cryptography</li>
                <li>
                  <c>MegaApp</c>
                  - callbacks to the application</li>
              </ul>
              <p> The SDK provides reference implementations of
                <c>FileAccess</c>
                (using <a href="http://pubs.opengroup.org/onlinepubs/9699919799/" target="_new">POSIX</a> calls),
                <c>HttpIO</c>
                (using <a href="http://curl.haxx.se" target="_new">cURL</a>) and of
                <c>PrnGen</c>
                ,
                <c>SymmCipher</c>
                and
                <c>AsymmCipher</c>
                (using <a href="http://www.cryptopp.com/" target="_new">Crypto++</a>). If you decide to use cURL in your application, please ensure that it was built with <a href="http://c-ares.haxx.se/" target="_new">c-ares</a> support for asynchronous DNS requests. Some platforms (e.g. MacOS and Fedora) bundle cURL binaries that were compiled with threaded-resolver support - these will <b>not</b> work. </p>
              <h2>6.2 Usage</h2>
              <p>To access MEGA, an application needs to instantiate three classes: </p>
              <ul>
                <li>its own implementation of the
                  <c>MegaApp</c>
                  interface</li>
                <li>its own implementation of the
                  <c>HttpIO</c>
                  interface</li>
                <li>
                  <c>MegaClient</c>
                </li>
              </ul>
              <p>Then, the application must call
                <c>MegaClient</c>
                's
                <c>wait()</c>
                immediately before or instead of blocking for events itself. If
                <c>wait()</c>
                wishes to block, it calls
                <c>HttpIO</c>
                's
                <c>waitio()</c>
                , supplying a timeout. The application can either piggyback its own wakeup criteria onto the socket events/timeout in
                <c>waitio()</c>
                , or record the criteria
                <c>waitio()</c>
                gets waken up by and include these in its own blocking logic. The supplied SDK example (megaapp.cpp) uses the former approach, adding
                <c>fileno(stdin)</c>
                to the
                <c>select()</c>
                fd set to process user input in real time.</p>
              <p>The application must call MegaClient's
                <c>exec()</c>
                at least once after every wakeup by the
                <c>waitio()</c>
                criteria (it doesn't hurt to call it too often).</p>
              <h2>6.3 Data structures</h2>
              <p>A MEGA session consists of: </p>
              <ul>
                <li>nodes (
                  <c>MegaClient::nodes</c>
                  )</li>
                <li>users (
                  <c>MegaClient::users</c>
                  )</li>
                <li>active file transfers (
                  <c>MegaClient::ft</c>
                  )</li>
                <li>the root nodes' handles (
                  <c>MegaClient::rootnodes</c>
                  )</li>
                <li>the logged in user's own handle and e-mail address (
                  <c>MegaClient::me</c>
                  ,
                  <c>MegaClient::myemail</c>
                  )</li>
              </ul>
              <h2>6.3.1 Nodes</h2>
              <p>A node has the following properties: </p>
              <ul>
                <li>handle (caveat: the application-side handle bit layout is endian-dependent - do not transfer between systems using different CPU architectures!)</li>
                <li>type (file, folder, ...)</li>
                <li>its parent (if any)</li>
                <li>its children (if any)</li>
                <li>file size (if file node)</li>
                <li>file attributes (if file node)</li>
                <li>attributes (such as file/folder name)</li>
                <li>crypto key</li>
                <li>creation and modification times</li>
                <li>owner</li>
                <li>share information (share key, outgoing share peers, incoming share properties)</li>
                <li>a generic pointer to private application data</li>
                <li>a removed flag used to notify node deletion</li>
              </ul>
              <p>Please refer to the supplied source code for details.</p>
              <h2>6.3.2 Users</h2>
              <p>A third-party user is part of the session either because he is in a contact relationship with the session user, or because he owns at least one of the session's nodes. A user record is also created when a share is added to a previously unregistered e-mail address.  Users can be referenced by their handle or by their e-mail address.</p>
              <p>User properties: </p>
              <ul>
                <li>handle</li>
                <li>email address (case-insensitive unique key)</li>
                <li>name</li>
                <li>contact visibility</li>
                <li>shared node handles</li>
                <li>public key</li>
                <li>time the user was added as a contact</li>
                <li>user properties</li>
              </ul>
              <h2>6.4 File I/O</h2>
              <h2>6.4.1 File transfers</h2>
              <p>Multiple concurrent file transfers are supported. It is strongly suggested not to run more than one large upload and one large download in parallel to avoid network congestion (there will be little, if any, speed benefit). A file transfer can aggregate multiple TCP channels (recommended starting point: 4) for greater throughput. File transfers can be aborted at any time by calling
                <c>MegaClient::tclose()</c>
                . Significant local network congestion during uploads is common with ADSL uplinks and can be prevented by enabling an automatic or fixed rate limit.</p>
              <h2>6.4.2 Transfer queueing</h2>
              <p>Applications that transfer batches of files should do using the engine's transfer queueing functionality. It uses pipelining (new transfers are dispatched approximately three seconds before the end of the current transfer) to reduce or eliminate the dead time between files. Failed transfers are retried with exponential backoff.</p>
              <h2>6.4.3 File attributes</h2>
              <p>Files can have <i>attributes</i>. Only the original creator of a file can update its attributes. All nodes referencing the same <i>encrypted</i> file see the same attributes. Attributes carry a 16-bit type field. The client access engine supports attaching file attributes during or after the upload and their bulk retrieval.</p>
              <h2>6.3.5 Thumbnails</h2>
              <p>All applications capable of uploading image files <i>should</i> add thumbnails in the process (remember that there is no way for us to do this on the server side). Thumbnails are stored as type 0 file attributes and should be 120p*120p JPEGs compressed to around 3-4 KB. The sample application supplied with the SDK demonstrates how to do this using the <a href="http://freeimage.sourceforge.net/" target="_new">FreeImage</a> library. As the extraction of a thumbnail from a large image can take a considerable amount of time, it is also suggested to perform this in separate worker threads to avoid stalling the application.</p>
              <h2>6.4   Quota enforcement</h2>
              <p>There are two types of quota limitations an application can encounter during its operation: Storage and bandwidth.  MEGA, by policy, is quite generous on both, which means that only a small fraction of your user base will ever run out of quota, but it is essential that if it happens, the situation is handled correctly - the user needs to be informed about the reason for his upload or download failing rather than being left in the dark with what looks like a malfunction.</p>
              <h2>6.4.1 Storage quota</h2>
              <p>An upload will be rejected with error
                <c>EOVERQUOTA</c>
                if there is not enough storage quota available to complete it. Once the upload has started, it will complete, even if you run out of disk space through other means in the meantime (e.g. by your Pro status expiring). This error will also occur if your application tries to send files to a third-party account without sufficient quota.</p>
              <h2>6.4.2 Bandwidth quota</h2>
              <p>A download attempt will be rejected with error
                <c>EOVERQUOTA</c>
                if the bandwidth consumption during the past five to six hours plus the residual size of all running downloads plus the size of the file to download would exceed the current per-IP bandwidth limit (if any).</p>
              <p>In contrast to uploads, running downloads <i>can</i> be interrupted with an out-of-quota error under certain circumstances, which will trigger a
                <c>quota_exceeded()</c>
                callback, and the download will retry automatically until bandwidth quota becomes available.</p>
              <h2>6.5 API access authorization</h2>
              <p>To access the MEGA API, applications need to present a valid API key, which can be obtained free of
                charge from <a class="clickurl" href="/sdk">https://mega.nz/sdk</a>.
                Please see the <a class="clickurl" href="/sdkterms">SDK terms of service</a> for details.</p>
              <h2 id="doc_7">7 Development process</h2>
              <p>The release of the C++ SDK is merely a starting point, and it will evolve over time. We'd like to hear from developers actually using it in their applications - if you find bugs, design flaws or other shortcomings, please get in touch at <a href="mailto:developers@mega.nz">developers@mega.nz</a>. MEGA is hiring, so be prepared to receive an offer if your feedback indicates that you are a bright mind.</p>
              <p>A developer forum and source code repository will be made available soon.</p>
              <h2 id="doc_8">8 Planned future enhancements</h2>
              <h2>8.1 Login acceleration</h2>
              <p>Large MEGA accounts can take a considerable amount of time to load. This is due to the sheer size of the state information that has to be read from the API cluster. There are two ways around this: </p>
              <ul>
                <li>Maintaining the account state in a local persistent database rather than in memory. Upon login, the client would ask the server for the number of operations that have affected the account since the last database update, and then decide whether it is more efficient to wipe the local state and reload, or to continue with the stored state and apply the queued updates to it (in the vast majority of cases, it will be the latter).</li>
                <li>The application initially loads only folder nodes and retrieves file nodes dynamically when they are actually needed.</li>
              </ul>
              <h2>8.2 Allow for existing files to be opened for writing</h2>
              <p>Currently, files cannot be modified after creation. This limitation will be overcome by using encrypted delta files.</p>
              <h2>8.3 Allow for integrity-checked partial reads</h2>
              <p>Currently, a file's integrity is verified only after it was downloaded in full. Chunk MAC verification will enable applications to ensure the integrity of partial reads.</p>
              <h2 id="doc_9">9 SDK sample client application</h2>
              <h2>9.1 Compiling and linking
                <c>megaclient</c>
              </h2>
              <p>To successfully build
                <c>megaclient</c>
                , you need the following:</p>
              <ul>
                <li>a POSIX-compliant environment</li>
                <li>a C++ compiler with STL</li>
                <li>libcurl, <b>built with c-ares</b></li>
                <li>a recent version of FreeImage</li>
                <li>libcrypto++</li>
                <li>libreadline</li>
              </ul>
              <p>At this time, the SDK does not come with an autoconf script, so you may have to manually adapt the Makefile to your system. </p>
              <h2>9.2 Using
                <c>megaclient</c>
              </h2>
              <p>Similar to the UNIX
                <c>ftp</c>
                command,
                <c>megaclient</c>
                displays a prompt and accepts commands to log into a MEGA account or exported folder link, list folder contents, create folders, copy, move and delete files and folders, view inbound and outbound folder shares, establish, modify and delete outbound folder shares, upload and download files, export links to folders and files, import file links, view the account's status and change its password.</p>
              <h2>9.3 Command reference</h2>
              <h2>9.3.1
                <c>login</c>
                - log into an account or folder link</h2>
              <p>To log into an account, specify the account's e-mail address and optionally the password (for which you will be prompted otherwise).</p>
              <p>To log into an exported folder link, specify the full link, including the key (prompting for the key has not been implemented yet).</p>
              <p>Note that exported folders cannot be written to.</p>
              <h2>9.3.2
                <c>mount</c>
                - display available filesystem trees</h2>
              <p>This command takes no parameters and displays the paths of your available filesystem trees (typically
                <c>/</c>
                for the main tree,
                <c>//in</c>
                for the inbox,
                <c>//bin</c>
                for the rubbish bin and
                <c>email:sharename</c>
                for inbound shares from user
                <c>email</c>
                .</p>
              <h2>9.3.3
                <c>ls</c>
                - list files and folders</h2>
              <p>
                <c>ls</c>
                lists the contents of the current folder (if given with the qualifier
                <c>-R</c>
                , it does so recursively) or the specified path.</p>
              <p>Paths can be relative or absolute. Valid absolute paths start with one of the prefixes displayed by the mount command.</p>
              <p>File and folder properties are displayed along with their names: File size and available file attributes, or exported folder links and outbound folder shares.</p>
              <h2>9.3.4
                <c>cd</c>
                - change current working directory</h2>
              <p>
                <c>cd</c>
                changes the current working directory to the specified folder path. If no path is given, it changes to
                <c>/</c>
                .</p>
              <h2>9.3.5
                <c>pwd</c>
                - display current folder</h2>
              <p>
                <c>pwd</c>
                displays the current folder as an absolute path.</p>
              <h2>9.3.6
                <c>lcd</c>
                - change current local working directory</h2>
              <p>
                <c>lcd</c>
                changes the current local working directory to the specified path.</p>
              <h2>9.3.7
                <c>get</c>
                - add file(s) to the download queue</h2>
              <p>
                <c>get</c>
                queues the specified file for download. If you specify a folder, all files contained in the folder are queued for download (but not the contents of its subfolders).</p>
              <h2>9.3.8
                <c>put</c>
                - add file(s) to the upload queue</h2>
              <p>
                <c>put</c>
                queues the specified file for upload. Patterns are supported -
                <c>put *.jpg</c>
                will upload all .jpg files present in the current local directory.</p>
              <h2>9.3.9
                <c>getq</c>
                and
                <c>putq</c>
                - list/remove/abort queued transfers</h2>
              <p>The queued transfers are listed with an index, target path (uploads only) and activity status. To cancel a transfer, specify its index.</p>
              <h2>9.3.10
                <c>mkdir</c>
                - create folders</h2>
              <p>
                <c>mkdir</c>
                creates an empty subfolder in the specified (or current) folder. Although MEGA permits identical folder names,
                <c>mkdir</c>
                fails if the folder already exists.</p>
              <h2>9.3.11
                <c>cp</c>
                ,
                <c>mv</c>
                - copy or move, rename files and folders</h2>
              <p>The specified source path or folder is copied or moved to the destination folder. If the destination indicates a new name in an existing folder, a rename takes place along the way.</p>
              <h2>9.3.12
                <c>rm</c>
                - delete file or folder</h2>
              <p>
                <c>rm</c>
                deletes the specified file or folder. If the folder contains files or subfolders, these are recursively deleted as well. All affected outbound shares and exported folder links are canceled in the process.</p>
              <p>The deletion is final. To take advantage of the rubbish bin functionality, use
                <c>mv path //bin</c>
                instead.</p>
              <h2>9.3.13
                <c>share</c>
                - manage outbound folder shares</h2>
              <p>
                <c>share</c>
                lists, creates, updates or deletes outbound shares on the specified folder. The folder cannot be in an inbound share.</p>
              <p>To list the existing shares on a folder, use
                <c>share path</c>
                .</p>
              <p>To cancel a folder share to a user, use
                <c>share path email</c>
                .</p>
              <p>To create or modify a folder share, use
                <c>share path email access</c>
                .</p>
              <p>Supported access levels are: Read-only (
                <c>r</c>
                ), read/write (
                <c>rw</c>
                ) and full (
                <c>full</c>
                ).</p>
              <h2>9.3.14
                <c>export</c>
                - create or cancel file or folder link</h2>
              <p>
                <c>export</c>
                creates a read-only file or folder link that contains the related encryption key. To cancel and existing link, add the keyword
                <c>del</c>
                .</p>
              <h2> 9.3.15
                <c>import</c>
                - import exported file </h2>
              <p>
                <c>import</c>
                adds the file described by the supplied link (importing folder links is currently unsupported) to the current folder.</p>
              <h2>9.3.16
                <c>putbps</c>
                - set upload speed limit</h2>
              <p>Uploading through a DSL line can cause significant outbound packet loss. You can limit the send rate by specifying an absolute maximum in bytes per second,
                <c>auto</c>
                to have the server figure out your line speed and leave approximately 10% of it idle, or
                <c>none</c>
                to transfer at full speed.</p>
              <p>It is currently not possible to change the send rate of an active upload. The setting will only affect subsequent uploads. </p>
              <h2>9.3.17
                <c>whoami</c>
                - display account details</h2>
              <p>
                <c>whoami</c>
                displays various account quota, balances and the session history.</p>
              <h2>9.3.18
                <c>passwd</c>
                - change account password</h2>
              <p>
                <c>passwd</c>
                prompts for the current password and then asks for the new password and its confirmation. No password quality checking is performed.</p>
              <h2>9.3.19
                <c>retry</c>
                - immediately retry all pending operations</h2>
              <p>
                <c>retry</c>
                resets all exponential backoff timers.</p>
              <h2>9.3.20
                <c>recon</c>
                - reconnect</h2>
              <p>
                <c>recon</c>
                tears down all existing server connections. This has no effect on ongoing operations other than causing transfers to take longer due to partially transferred chunks being discarded and having to be resent.</p>
              <h2>9.3.21
                <c>reload</c>
                - wipe and reload account state</h2>
              <p>
                <c>reload</c>
                purges the local state and forces a full reload from the server. This is useful in response to the detection of a race condition-related inconsistency between the client's view and the server state.</p>
              <h2>9.3.22
                <c>logout</c>
                - terminate current session</h2>
              <p>
                <c>logout</c>
                purges all local session state.</p>
              <h2>9.3.23
                <c>debug</c>
                - toggle debug mode</h2>
              <p>Debug mode outputs HTTP connection activity and the raw JSON API requests and responses.</p>
              <h2 id="doc_10">10 Method/callback overview</h2>
              <h2>10.1 Hashing a password</h2>
              <p>Hashes a UTF-8-encoded password and stores the result in the supplied buffer.</p>
              <p>Method:
                <c>error hashpw_key(const char* password, char* hash)</c>
              </p>
              <p>Return codes:
                <c>API_EARGS</c>
                in case of invalid UTF-8 encoding</p>
              <h2>9.2 Logging into an account</h2>
              <p>Initiates a session login based on the user e-mail address (case insensitive) and the corresponding password hash.</p>
              <p>Method:
                <c>void login(const char* email, const char* hash)</c>
              </p>
              <p>Callback:
                <c>
                  login_result(error e)
                </c>
              </p>
              <p>Error codes:
                <c>API_ENOENT</c>
                : Invalid e-mail address or password,
                <c>API_EKEY</c>
                : Private key could not be decrypted</p>
              <h2>9.3 Logging into an exported folder</h2>
              <p>Method:
                <c>void folderaccess(const char* node, const char* key)</c>
              </p>
              <p>Callback: none (does not interact with the server, proceed with calling
                <c>fetchnodes()</c>
                )</p>
              <h2>9.3   Fetching the session's nodes and users</h2>
              <p>Method:
                <c>void fetchnodes()</c>
              </p>
              <p>Callback: fetchnodes_result(client, error e)</p>
              <p>Upon successful completion, also calls nodes_updated().</p>
              <h2>9.4 Retrieving user account details, quota and history</h2>
              <p>Method:
                <c>void getaccountdetails(AccountDetails* result, int storage, int transfer, int pro, int transactions, int purchases, int sessions)</c>
              </p>
              <p>Updates the supplied AccountDetails structure with information on current storage and transfer utilization and quota, Pro status, and the transaction and session history. You can specify which types of information you are interested in by setting the related flag to a non-zero value.</p>
              <h2>9.5 Changing the logged in account's password</h2>
              <p>Method:
                <c>error changepw(const char* currentpwhash, const char* newpwhash)</c>
              </p>
              <p>Callback:
                <c>
                  changepw_result(error e)
                </c>
              </p>
              <p>Return code:
                <c>API_EACCESS</c>
                if no user session exists.</p>
              <h2>9.6 Updating a node's attributes (with instant completion)</h2>
              <p>Method:
                <c>
                  error setattr(Node* node, const char** newattr)
                </c>
              </p>
              <p>Return value: API_EACCESS if node not writable.</p>
              <p>Callback: setattr_result(handle nodehandle, error e)</p>
              <p>The node's current attributes are pushed to the server. The optional
                <c>newattr</c>
                parameter specifies attribute deltas as NULL-terminated sequence of attribute name/attribute C-string pointer pairs. In
                <c>setattr_result()</c>
                ,
                <c>nodehandle</c>
                is the node's handle.</p>
              <h2>9.7  Moving a node to a new parent folder (with instant completion)</h2>
              <p>Method:
                <c> error rename(Node* node, Node* newparent)</c>
              </p>
              <p>Return value:
                <c>API_EACCESS</c>
                if node's parent or newparent are not writable (with full and read/write access, respectively) or the move would be between different user accounts,
                <c>API_ECIRCULAR</c>
                if a circular linkage would result.</p>
              <p>Callback: rename_result(handle nodehandle, error e)</p>
              <p>The node (along with all of its children) is moved to the new parent node, which must be part of the same user account as the node itself. You cannot move a mode to its own subtree.</p>
              <h2>9.8 Deleting a node tree (with instant completion)</h2>
              <p>Method: error unlink(Node* node)</p>
              <p>Return value:
                <c>API_EACCESS</c>
                if the node's parent is not writable (with full access). </p>
              <p>Callback: unlink_result(handle nodehandle, error e)</p>
              <p>The node and all of its subnodes are deleted. The node's parent must be writable (with full access). Affected outbound shares are canceled.</p>
              <h2>9.9 Transferring files</h2>
              <p>Uploads and downloads are started with
                <c>topen()</c>
                , which returns a <i>transfer descriptor</i> identifying the transfer. Multiple transfers can run in parallel, and each transfer can use multiple TCP connections in parallel. Efficient transfer queueing with pipelining is available. Uploads can be speed-limited using an absolute or a dynamic cap.</p>
              <p>Progress information is conveyed through the callback
                <c>transfer_update(int td, m_off_t bytes, m_off_t size, dstime starttime)</c>
                , whereby td identifies the transfer, bytes denotes the number of bytes transferred so far, size indicates the total transfer size, and starttime is the time the transfer started.</p>
              <p>A running transfer can be aborted at any time by calling
                <c>tclose(int td)</c>
                . Failure-indicating callbacks perform the
                <c>tclose()</c>
                implicitly. The callback indicating a transient HTTP error,
                <c>transfer_error(int td, int httpcode, int count)</c>
                will call
                <c>tclose()</c>
                if the application returns a non-zero value.</p>
              <h2>9.9.1 Uploading</h2>
              <p>Method:
                <c>int topen(const char* localfilename, int speedlimit, int connections)</c>
              </p>
              <p>
                <c>speedlimit</c>
                - maximum upload speed in bytes/second or -1 for approx. 90% of the line speed</p>
              <p>
                <c>connections</c>
                - number of parallel connections to use (default: 3)</p>
              <p>Return value: transfer descriptor or
                <c>API_ETOOMANY</c>
                if all transfer channels are busy,
                <c>API_ENOENT</c>
                if file failed to open. </p>
              <p>Callback upon successful completion:
                <c>transfer_complete(int td, handle uploadhandle, const byte* uploadtoken, const byte* filekey, SymmCipher* filekey)</c>
              </p>
              <p>Callback upon failure:
                <c>transfer_failed(int td, error e)</c>
              </p>
              <h2>9.9.2 Downloading</h2>
              <p>Method:
                <c>int topen(handle nodehandle, const byte* key, m_off_t start, m_off_t len, int c)</c>
              </p>
              <p>
                <c>nodehandle</c>
                is the handle of the node to download (if key is set, the handle part of the exported file link)</p>
              <p>
                <c>key</c>
                is the base64-decoded key part of the exported file link if set </p>
              <p>
                <c>start</c>
                and
                <c>len</c>
                can be set to download only a slice of the file (default: 0, -1 for the full file)</p>
              <p>
                <c>c</c>
                denotes the number of parallel TCP connections that this download should employ. </p>
              <p>Return value: transfer descriptor or
                <c>API_ETOOMANY</c>
                if all transfer channels are busy,
                <c>API_ENOENT</c>
                if local file is not present,
                <c>API_EACCESS</c>
                if attempting to download a non-file </p>
              <p>Callback upon successful opening of the file to download:
                <c> topen_result(int td, string* filename, const char* fa, int pfa) </c>
              </p>
              <p>
                <c>td</c>
                identifies the transfer</p>
              <p>
                <c>filename</c>
                is the name of the file as specified by the node attribute
                <c>'n'</c>
              </p>
              <p>
                <c>fa</c>
                are the file attributes available for this file</p>
              <p>
                <c>pfa</c>
                is a flag that indicates whether the requesting user is allowed to write file attributes (i.e., is the file's owner)</p>
              <p>Callback upon succcessful completion:
                <c>transfer_complete(int td, chunkmac_map* macs, const char* fn)</c>
              </p>
              <p>
                <c>td</c>
                identifies the transfer</p>
              <p>
                <c>macs</c>
                contains the MAC hash for each file chunk
              </p>
              <p>
                <c>fn</c>
                is the filename (UTF-8)</p>
              <p>Callback upon failure:
                <c>transfer_failed(int td, string& filename, error e)</c>
              </p>
              <p>Callback upon reaching the transfer limit:
                <c>transfer_limit(int td)</c>
              </p>
              <h2>9.9.3 Transfer queueing</h2>
              <p>The engine maintains separate upload and download queues,
                <c>putq</c>
                and
                <c>getq</c>
                . Transfers are started by pushing transfer objects (classes
                <c>FilePut</c>
                and
                <c>FileGet</c>
                onto these queues). You no longer need to call
                <c>topen()</c>
                /
                <c>tclose()</c>
                yourself, but you still need to process the transfer callbacks. A transfer is considered failed if no bytes were transmitted for at least XFERTIMEOUT deciseconds, in which case it will be aborted and repeated indefinitely with exponential backoff.</p>
              <p>The main benefit of using the engine-supplied transfer queueing is not the reduced application complexity, but the built-in overlapping transfer pipelining that reduces the impact of transitions between files on your overall throughput.</p>
              <h2>9.10 Adding nodes</h2>
              <p>Nodes can be added to
                putnodes_result(error e, targettype t, NewNode* nn) </p>
              <p>Method:
                <c>void putnodes(handle parenthandle, NewNode* newnodes, int numnodes)</c>
              </p>
              <p>
                <c>parenthandle</c>
                is the handle of the new nodes' parent node.</p>
              <p>
                <c>newnodes</c>
                is an array of populated NewNode structures. Under some circumstances, this array will be accessed after the call to
                <c>putnodes()</c>
                has already returned. Therefore, <b>always</b> allocate this array from the heap and free it in
                <c>putnodes_result()</c>
                .</p>
              <p>
                <c>numnodes</c>
                is the number of NewNode records present.</p>
              <p>Callback: putnodes_result(client,error) if the operation </p>
              <h2>9.15 Create folder share or create folder key</h2>
              <p>Method: setshare(node,targetuser,accesslevel)</p>
              <p>Callback: share_result(client,error)</p>
              <p>Callback: share_result(client,int,error)</p>
              <h2>9.16 Check if user is logged into a full account</h2>
              <p>Method: loggedin()</p>
              <p>Returns: 1 if logged in, 0 otherwise</p>
              <h2>9.17 Check access to a node</h2>
              <p>Method: checkaccess(node,level)</p>
              <p>Returns: 1 if access allowed, 0 otherwise</p>
              <h2>9.18 Check if a move node operation would be permitted</h2>
              <p>Method: checkmove(node,targetnode)</p>
              <p>Returns: error code (API_OK, API_EACCESS or API_ECIRCULAR)</p>
              <h2>9.19 Prefix and encrypt JSON object for use as node attribute string</h2>
              <p>Method: makeattr(cipher,targetstring,jsonstring,length)</p>
              <h2>9.20 Request for new FileAccess object</h2>
              <p>Callback: newfile()</p>
              <p>Returns: Application-specific FileAccess object</p>
              <h2>9.21 User update notification</h2>
              <p>Callback: users_updated(client,users,count) - users were added or updated (users are never deleted)</p>
              <h2>9.22 Node update notification</h2>
              <p>Callback: node_updated(client,nodes,count) - nodes were added, updated or removed</p>
              <p>Callback: notify_retry(client,time) - specifies time in decisecons until the next retry</p>
              <p>Callback: reload(client,reason) - possible inconsistency, reload account state</p>
              <h2 id="doc_10e">10 Error codes</h2>
              <ul>
                <li>API_OK (0): Success</li>
                <li>API_EINTERNAL (-1): An internal error has occurred. Please submit a bug report, detailing the exact circumstances in which this error occurred.</li>
                <li>API_EARGS (-2): You have passed invalid arguments to this command.</li>
                <li>API_EAGAIN (-3) (always at the request level): A temporary congestion or server malfunction prevented your request from being processed. No data was altered. Retry. Retries must be spaced with exponential backoff.</li>
                <li>API_ERATELIMIT (-4): You have exceeded your command weight per time quota. Please wait a few seconds, then try again (this should never happen in sane real-life applications).</li>
                <li>API_EFAILED (-5): The upload failed. Please restart it from scratch.</li>
                <li>API_ETOOMANY (-6): Too many concurrent IP addresses are accessing this upload target URL.</li>
                <li>API_ERANGE (-7): The upload file packet is out of range or not starting and ending on a chunk boundary.</li>
                <li>API_EEXPIRED (-8): The upload target URL you are trying to access has expired. Please request a fresh one.</li>
                <li>API_EOENT (-9): Object (typically, node or user) not found</li>
                <li>API_ECIRCULAR (-10): Circular linkage attempted</li>
                <li>API_EACCESS (-11): Access violation (e.g., trying to write to a read-only share)</li>
                <li>API_EEXIST (-12): Trying to create an object that already exists</li>
                <li>API_EINCOMPLETE (-13): Trying to access an incomplete resource</li>
                <li>API_EKEY (-14): A decryption operation failed (never returned by the API)</li>
                <li>API_ESID (-15): Invalid or expired user session, please relogin</li>
                <li>API_EBLOCKED (-16): User blocked</li>
                <li>API_EOVERQUOTA (-17): Request over quota</li>
                <li>API_ETEMPUNAVAIL (-18): Resource temporarily not available, please try again later</li>
                <li>API_ETOOMANYCONNECTIONS (-19): Too many connections on this resource</li>
                <li>API_EWRITE (-20): Write failed</li>
                <li>API_EREAD (-21): Read failed</li>
                <li>API_EAPPKEY (-22): Invalid application key; request not processed</li>
              </ul>
              <h2 id="doc_11">11 Under the hood</h2>
              <p>Knowledge of the following low-level details is not required to successfully develop MEGA client applications. It is provided as a reference to those who are interested in fully understanding how MEGA's API works.</p>
              <h2>11.1 Communication protocol</h2>
              <p>The MEGA API is based on a simple HTTP/JSON request-response scheme. Requests are submitted as arrays of command objects and can be initiated by both the client and the server, effectively resulting in bidirectional RPC capability. To see the raw request flow in the SDK's megaclient sample app, use the debug command.</p>
              <h2>11.2 Cryptography</h2>
              <p>All symmetric cryptographic operations are based on AES-128. It operates in cipher block chaining mode for the file and folder attribute blocks and in counter mode for the actual file data. Each file and each folder node uses its own randomly generated 128 bit key. File nodes use the same key for the attribute block and the file data, plus a 64 bit random counter start value and a 64 bit meta MAC to verify the file's integrity.</p>
              <p>Each user account uses a symmetric master key to ECB-encrypt all keys of the nodes it keeps in its own trees. This master key is stored on MEGA's servers, encrypted with a hash derived from the user's login password.</p>
              <p>File integrity is verified using chunked CBC-MAC. Chunk sizes start at 128 KB and increase to 1 MB, which is a reasonable balance between space required to store the chunk MACs and the average overhead for integrity-checking partial reads.</p>
              <p>In addition to the symmetric key, each user account has a 2048 bit RSA key pair to securely receive data such as share keys or file/folder keys. Its private component is stored encrypted with the user's symmetric master key.</p>
              <h2>11.3 Shared folders</h2>
              <p>The owner of the folder is solely responsible for managing access; shares are non-transitive (shares cannot be created on folders in incoming shares). All participants in a shared folder gain cryptographic access through a common share-specific key, which is passed from the owner (theoretically, from anyone participating in the share, but this would create a significant security risk in the event of a compromise of the core infrastructure) to new participants through RSA. All keys of the nodes in a shared folder, including its root node, are encrypted to this share key. The party adding a new node to a shared folder is responsible for supplying the appropriate node/share-specific key. Missing node/share-specific keys can only be supplied by the share owner.</p>
              <h2>11.4 Unauthenticated delivery</h2>
              <p>MEGA supports secure unauthenticated data delivery. Any fully registered user can receive files or folders in their inbox through their RSA public key.</p>
              <h2>11.5 Login Sessions</h2>
              <p>Each login starts a new session. For regular accounts, this involves the server generating a random session token and encrypting it to the user's private key. The user password is considered verified if it successfully decrypts the private key, which then decrypts the session token.</p>
              <p>To prevent remote offline dictionary attacks on a user's password, the encrypted private key is only supplied to the client if a hash derived from the password is presented to the server.</p>
              .
              <h2>11.6 API request flow and execution</h2>
              <p>API requests flow in two directions: client &rarrow; server and server &rarrow; client</p>
              <p>Client-server requests are issued as HTTP POST with a raw JSON payload. A request consists of one or multiple commands and is executed as a single atomic, isolated and consistent transaction - in the event of a request-level error response, no data was altered. Requests are idempotent - sending the same request multiple times is equivalent to sending it once, which makes it safe to retry them, e.g. in case of intermittent network issues. Each request must therefore be tagged with a session-unique identifier (e.g., a sequence number) to prevent inadvertent cache hits caused by preceding identical requests.</p>
              <p>While a request is executed, all users that may be affected by it are locked. This includes the requesting user and all users that are in a shared folder relationship and/or in the contact list. A request may return the error code EAGAIN in the event of a failed locking attempt or a temporary server-side malfunction. The request is likely to complete when retried. Client applications must implement exponential backoff (with user-triggerable immediate retry) and should inform the user of a possible server or network issue if the EAGAIN condition persists or no response is received for more than a few seconds.</p>
              <p>A successfully executed request returns an array of result objects, with each result appearing in the same array index location as the corresponding command.</p>
              <h2>11.6.1 Request URL format</h2>
              <p> Target URL: <a class="clickurl" href="/doc">https://g.api.mega.co.nz/cs?id=sequence_number&ak=appkey&&#91;&sid=sessionid|&n=node&#93;</a>
              </p>
              <ul>
                <li>sequence_number is a session-unique number that is incremented per dispatched request (but not changed when requests are repeated in response to network issues or EAGAIN)</li>
                <li>appkey is the application's key</li>
                <li>appkey is the application's key</li>
                <li>node is the node token of the filesystem tree authentication mode</li>
              </ul>
              <h2>11.6.2 POST JSON request payload structure</h2>
              <p> The JSON object shall be sent as the payload of a raw POST request. No additional framing shall take place. The Content-Type HTTP header is not processed, but should be set to application/json.<br>
                Its structure is an array of commands: &#91;cmd1,cmd2,...&#93;<br>
                with cmd = { a : command type, &#91;argument : value&#93;* }.<br>
              </p>
              <h2>11.6.3 POST JSON response payload structure</h2>
              <p>The response to the request is a raw JSON object of content-type application/json.</p>
              <p>It is structured as single number (e.g. -3 for EAGAIN) in the case of a request-level error or as an array of per-command return objects: &#91;res1,res2,...&#93;</p>
              <p>To prevent infrastructure overload, dynamic rate limiting is in effect. Before a request is executed, the total "weight" of the commands it contains is computed and checked against the current balance of the requesting IP address. If the total exceeds a defined threshold, the request is rejected as a whole and must be repeated with exponential backoff</p>
              <h2>11.7 Server-client requests</h2>
              <p>As a server cannot reliably establish a connection to a client, server-client requests have to be polled by the latter through a blocking read loop.</p>
              <h2>11.7.1 Request URL format</h2>
              <p>Target URL: <a class="clickurl" href="/doc">https://g.api.mega.co.nz/sc?id=sequence_reference&#91;&sid=sessionid|&n=node&#93;&#91;ssl=1&#93;</a>
              </p>
              <ul>
                <li>sequence_reference tells the server which server-client request(s) to deliver next. It is initialized from the response to a filesystem tree fetch (f command).</li>
                <li>sessionid is the session ID of the user session authentication mode</li>
                <li>node is the node token of the filesystem tree authentication mode</li>
                <li>ssl=1 forces an HTTPS URL for the returned wait_url (which is needed for most browsers, but not in an application context)</li>
              </ul>
              <h2>11.7.2 POST JSON response payload structure</h2>
              <p>A request level error is received as a single number (e.g. -3 for EAGAIN) or a raw JSON object with content-type application/json. Its structure is as follows:<br>
                { a : &#91;req1,req2,...&#93;, &#91; sn : sequence_reference | w : wait_url &#93; }</p>
              <ul>
                <li>req&#178; are server-client requests</li>
                <li>sequence_reference updates the sequence reference that is used the invocation of the /cs request URL</li>
                <li>wait_url requests that the client connects to this (potentially long) URL, which will block until new requests are ready for delivery, so once it disconnects (with an HTTP 200 OK response and a content-length of 0), the polling process shall loop </li>
                <li>back to fetching new requests, using the current sequence_reference.</li>
              </ul>
              <h2>11.8 JSON data encoding</h2>
              <p>As JSON is not binary clean, all non-ASCII data has to be encoded. For binary data, the MEGA API uses a variation of base64 with -_ instead of +/ and the trailing = stripped (where necessary, the actual payload length is heuristically inferred after decoding, e.g. by stripping trailing NULs). UNICODE text has to be encoded as UTF-8.</p>
              <h2>11.9 API data types</h2>
              <p>The MEGA API uses the following major data types:</p>
              <h2>11.9.1 Node handles</h2>
              <p>Node handles are eight alphanumeric characters in length and case sensitive.</p>
              <h2>11.9.2 User handles</h2>
              <p>User handles consist of eleven base64-characters.</p>
              <h2>11.9.3 Encryption keys</h2>
              <p>Encryption keys are always base64-encoded. The following key types exist:</p>
              <ul>
                <li>Symmetric AES keys (22 characters)</li>
                <li>Folder node keys (22 characters)</li>
                <li>File node keys (43 characters)</li>
                <li>RSA public/private keys (2048 bit: 348/875 characters)</li>
                <li>Node and file keys in a share context are transmitted in a compound per-share format: sharehandle:key/sharehandle:key/... - each key is encrypted to its corresponding share handle</li>
              </ul>
              <h2>11.10 File encryption</h2>
              <p> MEGA uses client-side encryption/decryption to end-to-end-protect file transfers and storage. Data received from clients is stored and transmitted verbatim; servers neither decrypt, nor re-encrypt, nor verify the encryption of incoming user files. All cryptographic processing is under the control of the end user.<br>
                To allow for integrity-checked partial reads, a file is treated as a series of chunks. To simplify server-side processing, partial uploads can only start and end on a chunk boundary. Furthermore, partial downloads can only be integrity-checked if they fulfil the same criterion.<br>
                Chunk boundaries are located at the following positions:<br>
                0 / 128K / 384K / 768K / 1280K / 1920K / 2688K / 3584K / 4608K / ... (every 1024 KB) / EOF<br>
                A file key is 256 bits long and consists of the following components:<br>
              </p>
              <ul>
                <li>A 128 bit AES-128 key k</li>
                <li>The upper 64 bit n of the counter start value (the lower 64 bit are starting at 0 and incrementing by 1 for each AES block of 16 bytes)</li>
                <li>A 64 bit meta-MAC m of all chunk MACs</li>
              </ul>
              <p> A chunk MAC is computed as follows (this is essentially CBC-MAC, which was chosen instead of the more efficient OCB over intellectual property concerns):<br>
                h := (n &lt;&lt; 64) + n<br>
                For each AES block d: h := AES(k,h XOR d)<br>
                A chunk is encrypted using standard counter mode:<br>
                For each AES block d at block position p: d' := d XOR AES(k,(n &lt;&lt; 64)+p)<br>
                MAC computation and encryption can be performed in the same loop.<br>
                Decryption is analogous.<br>
                To obtain the meta-MAC m, apply the same CBC-MAC to the resulting block MACs with a start value of 0. The 64 bit meta-MAC m is computed as ((bits 0-31 XOR bits 32-63) &lt;&lt; 64) + (bits 64-95 XOR bits 96-127). </p>
              <h2>11.11 Uploads</h2>
              <p>Uploads are performed by POSTing raw data to the target URL returned by the API u command. If so desired, an upload can be performed in chunks. Chunks can be sent in any order and can be of any size, but they must begin and end on a chunk boundary. The byte offset x of a chunk within the file is indicated by appending /x to the URL. Multiple chunks can be sent in parallel. After a chunk completes, the server responds with a status message, which can be:</p>
              <ul>
                <li>Empty - successful receipt</li>
                <li>A (negative) error code in decimal ASCII representation, typically requiring a restart of the upload from scratch</li>
                <li>A 27-character base64-encoded completion handle that must be used in conjunction with the p (put node) API command to complete the upload</li>
              </ul>
              <p> The per-upload encryption key must be generated by a strong random number generator. Using a weak one will undermine the confidentiality and integrity of your data. </p>
              <h2>11.12 Downloads</h2>
              <p> TCP throughput on high-latency links is adversely affected by slow congestion window growth, insufficient send or receive buffer size and (even mild) packet loss. All of these factors can be mitigated by using multiple transfer connections in parallel. Client applications are encouraged to offer users to configure up to six parallel connections in each direction. The recommended default value is four. </p>
              <h2>11.14 HTTPS vs. HTTP</h2>
              <p> All MEGA servers support HTTPS access - this is due to many web browsers enforcing a policy where HTTP requests cannot be made from an HTTPS page at all (IE, Firefox 18+) or at least trigger a visual warning (Chrome, Firefox until 17). However, only two types of requests actually benefit from and therefore require HTTPS: The loading of https://mega.nz/index.html and the API request interface. Neither the hash-protected loading of static .html and .js components, nor the waiting for new server-client requests, nor already encrypted and MAC'ed data transfers from and to the storage cluster benefit from HTTPS in any meaningful way. Client applications are therefore required to use SSL for access to the API interface, but strongly discouraged from doing so for wait requests and bulk file transfers.<br>
              </p>
              <p>MEGA's HTTPS access supports most ciphers/hashes and uses strong 2048 bit RSA where SSL is relevant (i.e. on the root HTML and the API servers) and RC4/MD5 with CPU-saving 1024 bit RSA where it is not (i.e. on static HTML and storage servers).<br>
              </p>
              <p>PFS ("perfect forward secrecy") is supported on the API servers only, because secrecy is not required for public static content. </p>
            </div>
          </div>
        </div>
      </div>
      <div class="clear"></div>
    </div>
  </div>
</div>
