/**
 * `MegaChunkLoader`
 * ---------------------------------------------------------------------------------------------------------------------
 * Overrides the default `webpack` chunk loading mechanism (`__webpack_require__.l`) to integrate
 * `React.lazy`/`React.Suspense` with the `secureboot` architecture of the `webclient`, which ensures lazy-loaded chunks
 * go through MEGA's XHR + hash verification pipeline.
 *
 * 1) What
 * ---------------------------------------------------------------------------------------------------------------------
 * By default `webpack` loads chunks by injecting `script` tags with standard URLs. MEGA's security model requires all
 * code to be i) loaded via XHR (as to create blob URL entities) and ii) verified against a pre-computed SHA-256 hash.
 *
 * The default `webpack` loader behavior bypasses these integrity checks, which is not optimal. Additionally, the
 * `webpack` Hot Module Replacement (HMR) relies on injecting unverified code at runtime, which is incompatible with
 * the `webclient` integrity model.
 *
 * 2) How
 * ---------------------------------------------------------------------------------------------------------------------
 * This loader intercepts the `import()` calls generated by `React.lazy()`:
 *
 * i) `webpack` calls `__webpack_require__.l(url, done)` to load a chunk; we capture this call and derive the `url`
 * from `chunkFilename` in `webpack.config.js` (ex.: `js/chat/bundle.call.js`)
 * ii) we parse the URL as to extract the logical chunk name (ex.: `js/chat/bundle.call.js` -> `call` -> `chat:call_js`)
 * iii) we request the resource via `M.require('chat:call_js')` call, as `secureboot.js` maintains the respective
 * registry (jsl2) by mapping this logical key to the physical, hashed filename in production.
 * iv) `M.require` handles the XHR download and performs the SHA-256 hash check; if the hash does not match the
 * build-time manifest, the load is blocked to prevent tampering.
 * v) we call the `done()` callback on success, which allows the `React.Suspense` boundary to render the component.
 *
 * 3) Constraints
 * ---------------------------------------------------------------------------------------------------------------------
 * - the original `__webpack_require__.l` loader is intentionally not preserved as a fallback -- if a chunk fails the
 * integrity check (no `jsl2` entry) chunk loading fails securely rather than bypassing hash verification via the
 * default `script` tag injection.
 * - `splitChunks` is disabled; we want deterministic, manually defined chunks (via `webpackChunkName`) to
 * ensure 1:1 mapping with the `secureboot` registry.
 * - `hot` (HMR) is disabled; development can rely on standard page reloads in favor of ensuring the dev environment
 * mirrors the production security pipeline.
 */

const webpackRequire = typeof __webpack_require__ !== 'undefined' ? __webpack_require__ : null;

if (webpackRequire && webpackRequire.l) {
    const CHUNK_LOADER_DEBUG = d && localStorage.chunkLoaderDebug;
    const logger = MegaLogger.getLogger('MegaChunkLoader', { levelColors: { 'DEBUG': 'olive', 'ERROR': 'tomato' } });

    webpackRequire.l = (url, done) => {
        const startTime = CHUNK_LOADER_DEBUG ? performance.now() : 0;

        const match = url.match(/bundle\.([^.]+)\.js$/);
        const chunkName = match?.[1];

        const jslName = chunkName ? `chat:${chunkName.replace(/-/g, '_')}_js` : null;
        const hasJslEntry = jslName && jsl2[jslName];

        if (hasJslEntry) {
            M.require(jslName)
                .then(() => {
                    if (CHUNK_LOADER_DEBUG) {
                        const duration = (performance.now() - startTime).toFixed(1);
                        logger.debug(`Loaded '${chunkName}' chunk in ${duration}ms`, { chunkName, jslName, url });
                    }
                    done({ type: 'load' });
                })
                .catch(ex => {
                    logger.error(`Failed to load ${jslName}`, { error: ex, chunkName, jslName, url });
                    done({ type: 'error', target: { src: url } });
                });
        }
        else {
            logger.error(`Blocked insecure chunk load ('jsl2' entry missing)`, { chunkName, jslName, url });
            done({ type: 'error', target: { src: url } });
        }
    };
}
